#+PROPERTY: header-args:emacs-lisp :lexical yes :results value pp silent :comments both
* File header
** Early init
   Ideally, ~early-init.el~ should also get the copy of this block. Happens automatically with nix.
   #+begin_src emacs-lisp :tangle "early-init.el"
     (when (and (fboundp 'native-comp-available-p)
                (native-comp-available-p))
       (startup-redirect-eln-cache
        (file-name-concat
         (or (getenv "IMPERMANENCE_LOCAL_CACHE")
             (getenv "XDG_CACHE_HOME")
             (expand-file-name "~/.cache"))
         "emacs" "eln-cache/")))
   #+end_src
** Common folders
   #+begin_src emacs-lisp :tangle yes
     (eval-and-compile
       (defvar xdg-cache-home
         (or (getenv "IMPERMANENCE_LOCAL_CACHE")
             (getenv "XDG_CACHE_HOME")
             (expand-file-name "~/.cache")))

       (defun cache-file-name (&rest components)
         (apply #'file-name-concat (if (eq system-type 'windows-nt) (expand-file-name "~/.emacs.d/") xdg-cache-home) "emacs" components))

       (setf no-littering-etc-directory (cache-file-name "no-littering" "config"))
       (setf no-littering-var-directory (cache-file-name "no-littering" "data")))
   #+end_src
** MELPA on windows
   #+begin_src emacs-lisp :tangle yes
     (eval-and-compile
       (when (eq system-type 'windows-nt)
         (funcall 'require 'package)
         (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
         (package-initialize t)
         (when (not (package-installed-p 'no-littering))
           (package-install 'no-littering))
         (funcall 'require 'no-littering)))
   #+end_src
** No littering
   #+begin_src emacs-lisp :tangle yes
     ;; If no-littering is not loaded, it means that standalone compilation
     ;; happens right now. There are a bunch of packages doing IO even
     ;; during load (or adding it to various hooks/eval-when-load'ing),
     ;; let's give them a safe playground.
     ;; NOTE: `(use-package no-littering)` below is mandatory!
     (eval-when-compile
       (if (and (not (featurep 'no-littering))
                (not (eql system-type 'windows)))
         (setf user-emacs-directory (make-temp-file "throwaway-emacs.d-for-compilation" t))))

     (use-package no-littering
       :ensure t
       :no-require t)

     ;; look like a sandboxed nix build
     (unless (string= (getenv "HOME") "/homeless-shelter")
       (funcall 'require 'no-littering))
   #+end_src
** Track execution time

   Whatever happens before this point, we don't control
   (i.e. ~site-lisp.el~).  So I want to report full time but also the
   time it takes to execute this file with all hooks in 'after-init-hooks
   executed.
   #+begin_src emacs-lisp :tangle yes
     (defconst binarin/before-personal-init-file-time (current-time))
     (defun binarin/report-full-startup-time ()
       (message "Emacs initialized in %f seconds"
                (float-time (time-subtract (current-time)
                                           binarin/before-personal-init-file-time))))
   #+end_src

** Startup debug
   #+begin_src emacs-lisp :tangle no
     (eval-and-compile
       (setq use-package-verbose 'debug)
       (setq use-package-minimum-reported-time 0.0))

     (defun sh/current-time-microseconds ()
       "Return the current time formatted to include microseconds."
       (let* ((nowtime (current-time))
              (now-ms (nth 2 nowtime)))
         (concat (format-time-string "[%Y-%m-%dT%T" nowtime) (format ".%d]" now-ms))))

     (defun sh/ad-timestamp-message (FORMAT-STRING &rest args)
       "Advice to run before `message` that prepends a timestamp to each message.

     Activate this advice with:
     (advice-add message :before `sh/ad-timestamp-message)"
       (ignore args)                         ;
       (unless (string-equal FORMAT-STRING "%s%s")
         (let ((deactivate-mark nil)
               (inhibit-read-only t))
           (with-current-buffer "*Messages*"
             (goto-char (point-max))
             (if (not (bolp))
                 (newline))
             (insert (sh/current-time-microseconds) " ")))))

     (advice-add 'message :before 'sh/ad-timestamp-message)

     (message "Kick-off")
   #+end_src
** Warnings
   ~defvar~ to suppress compilation warnings about free variable assignment
   #+begin_src emacs-lisp :tangle yes
     (defvar native-comp-async-report-warnings-errors 'silent)
   #+end_src
** ~use-package~

   ~use-package~ documentation says to wrap it into
   ~eval-when-compile~, but it's not enough.

   #+begin_src emacs-lisp :tangle yes
     (require 'use-package)
   #+end_src

** Customization helpers
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dash :ensure t)
     (use-package f :ensure t)
     (use-package general :ensure t)
     (use-package anaphora :ensure t)
     (use-package s :ensure t)
     (require 's)
     (require 'f)
     (require 'cl-macs)
     (require 'dash)
     (require 'anaphora)
   #+END_SRC
** What system we are running on?
   #+begin_src emacs-lisp :tangle yes
     (defconst binarin/system-type
       (cond
        ((getenv "WSL_DISTRO_NAME") 'wsl)
        ((s-equals? system-type 'darwin) 'darwin)
        ((s-equals? system-type 'windows-nt) 'windows)
        (t 'linux)))
   #+end_src
* Appearance
** Theme
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package zenburn-theme
       :ensure t)
     (load-theme 'zenburn t)
     (set-face-attribute 'lazy-highlight nil :background "red")
   #+END_SRC

** Frame size
   Don't create too big of a frame on WSL (and it doesn't matter for tiling WMs).
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'default-frame-alist '(height . 24))
     (add-to-list 'default-frame-alist '(width . 80))
   #+END_SRC

** No toolbars/scrollbars
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; https://emacs.stackexchange.com/questions/39359/tool-bar-in-emacsclient

     (autoload 'toggle-scroll-bar "scroll-bar")
     (defun binarin/frame-tweaks (&optional frame)
       "My personal frame tweaks."
       (unless frame
         (setq frame (selected-frame)))
       (when frame
         (with-selected-frame frame
           (when (display-graphic-p)
             (toggle-scroll-bar -1)
             (menu-bar-mode -1)
             (tool-bar-mode -1)))))

     ;; For the case that the init file runs after the frame has been created.
     ;; Call of emacs without --daemon option.
     (binarin/frame-tweaks)

     ;; For the case that the init file runs before the frame is created.
     ;; Call of emacs with --daemon option.
     (add-hook 'after-make-frame-functions 'binarin/frame-tweaks t)

     (setf (alist-get 'vertical-scroll-bars default-frame-alist) nil)
   #+END_SRC




** Tab bar
   Only show tab bar when there is more than one tab
   #+begin_src emacs-lisp :tangle yes
     (general-setq tab-bar-show 1)
   #+end_src

** Font
   #+begin_src emacs-lisp :tangle yes
     (use-package all-the-icons
       :ensure t
       :if (display-graphic-p))

     (defvar binarin/nerd-font-family (if (eq binarin/system-type 'windows)
                                          "IosevkaTerm NFM"
                                        "IosevkaTerm Nerd Font"))


     ;; This is needed explicitly for other nerd-icons-based packages to work better (otherwise you can see a problem e.g. with a marked file in a dired buffer)
     (use-package nerd-icons
       :ensure t
       :config
       (setq nerd-icons-font-family binarin/nerd-font-family))
   #+end_src

   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'default-frame-alist
                  `(font . ,(cl-case binarin/system-type
                              (wsl "IosevkaTerm Nerd Font-18")
                              (windows "IosevkaTerm NFM-16")
                              (darwin "IosevkaTerm Nerd Font Mono-20")
                              (t "IosevkaTerm Nerd Font-16"))))

     (setf face-ignored-fonts '("Adobe Blank"))
   #+END_SRC
** Modeline
   #+begin_src emacs-lisp :tangle yes
     (use-package telephone-line
       :ensure t)

     (add-hook 'after-init-hook (lambda () (telephone-line-mode 1)))

     (custom-set-faces
      '(mode-line ((t (:box nil))))
      '(mode-line-inactive ((t (:box nil))))
      '(mode-line-highlight ((t (:box nil)))))


   #+end_src

** Long lines handling
   Truncate long lines by default:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default truncate-lines t)
   #+END_SRC

   Use fringe when ~visual-line-mode~ is in effect:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
   #+END_SRC

** Colorize color names
   #+begin_src emacs-lisp :tangle yes
     (use-package rainbow-mode
       :ensure t
       :commands (rainbow-mode))
   #+end_src
* Behaviour
** Startup profiling
   #+begin_src emacs-lisp :tangle yes
     (use-package esup
       :ensure t
       :commands (esup))
   #+end_src
** Date formatting
   #+begin_src emacs-lisp :tangle yes
     (setq system-time-locale "C")
   #+end_src
** Disable startup screen
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq inhibit-startup-screen t)
   #+END_SRC

** Disable ~suspend-frame~
   #+begin_src emacs-lisp :tangle yes
     (put 'suspend-frame 'disabled t)
   #+end_src

** Change "yes or no" to "y or n"
   #+begin_src emacs-lisp :tangle yes
     (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src
** Prevent accidental exit
   Prompt on C-x C-c - no more accidential exits
   #+begin_src emacs-lisp :tangle yes
     (setq confirm-kill-emacs #'y-or-n-p
           confirm-kill-processes nil)
   #+end_src
** Keeping a lot of history
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'savehist)
     (require 'recentf)
     (setq history-length 1000
           history-delete-duplicates t
           savehist-file (cache-file-name "savehist")
           savehist-additional-variables '(savehist-minibuffer-history-variables
                                           read-expression-history
                                           minibuffer-history
                                           file-name-history
                                           mark-ring
                                           search-ring
                                           extended-command-history
                                           kill-ring
                                           search-ring
                                           regexp-search-ring
                                           compile-history
                                           command-history)
           recentf-max-saved-items 1000)

     (savehist-mode 1)
     (recentf-mode 1)

     (defun binarin/recentf-save-alist ()
       (let ((inhibit-message t))
         (recentf-save-list)))

     (run-at-time nil 60 'binarin/recentf-save-alist)
   #+END_SRC
** Writeable grep buffers
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package wgrep
       :ensure t
       :hook
       (grep-setup-hook . wgrep-setup))
   #+END_SRC
** Completion everywhere
   #+begin_src emacs-lisp :tangle yes
     (use-package vertico
       :ensure t)
     (vertico-mode)
     (general-define-key :keymaps 'minibuffer-mode-map
                         "C-l" 'vertico-directory-delete-word)

     ;; showing additional docs during completion
     (use-package marginalia
       :ensure t
       :bind (:map minibuffer-local-map
                   ("M-A" . marginalia-cycle))
       :init
       (marginalia-mode))

     (use-package nerd-icons-completion
       :ensure t
       :after marginalia
       :config
       (nerd-icons-completion-mode)
       (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

     ;; search by first letters of words in any order
     (use-package orderless
       :ensure t)
     (setq completion-styles '(orderless basic)
           completion-category-overrides '((file (styles basic partial-completion))))

     (use-package consult
       :ensure t
       :commands (consult-history)
       :autoload (consult-register--candidates consult--get-location consult--jump-state consult-xref)
       :bind
       (("C-c M-x"   . consult-mode-command)
        ("C-h C-i"   . consult-info)                ;; The same as "C-h TAB"
        ("M-y"       . consult-yank-pop)
        ("C-x r s"   . consult-register-store)
        ("C-x r SPC" . consult-register-store)
        ("C-x r j"   . consult-register-load)

        ;; C-x bindings in `ctl-x-map'
        ("C-x M-:"   . consult-complex-command)     ;; orig. repeat-complex-command

        ("C-x b"     . consult-buffer)              ;; orig. switch-to-buffer

        ("C-x 4 b"   . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
        ("C-x 5 b"   . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
        ("C-x t b"   . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
        ("C-x r b"   . consult-bookmark)            ;; orig. bookmark-jump
        ("C-x p b"   . consult-project-buffer)      ;; orig. project-switch-to-buffer

        ;; M-g bindings in `goto-map'
        ("M-g e"     . consult-compile-error)
        ("M-g f"     . consult-flymake)             ;; Alternative: consult-flycheck
        ("M-g g"     . consult-goto-line)           ;; orig. goto-line
        ("M-g M-g"   . consult-goto-line)           ;; orig. goto-line
        ("M-g o"     . consult-outline)             ;; Alternative: consult-org-heading
        ("M-g m"     . consult-mark)
        ("M-g k"     . consult-global-mark)
        ("M-g i"     . consult-imenu)
        ("M-g I"     . consult-imenu-multi)

        ;; M-s bindings in `search-map'
        ("M-s d"     . consult-find)                ;; Alternative: consult-fd
        ("M-s c"     . consult-locate)
        ("M-s g"     . consult-grep)
        ("M-s G"     . consult-git-grep)
        ("M-s r"     . consult-ripgrep)
        ("M-s l"     . consult-line)
        ("M-s L"     . consult-line-multi)
        ("M-s k"     . consult-keep-lines)
        ("M-s u"     . consult-focus-lines)

        ;; Isearch integration
        ("M-s e"     . consult-isearch-history)
        :map isearch-mode-map
        ("M-e"       . consult-isearch-history)     ;; orig. isearch-edit-string
        ("M-s e"     . consult-isearch-history)     ;; orig. isearch-edit-string
        ("M-s l"     . consult-line)                ;; needed by consult-line to detect isearch
        ("M-s L"     . consult-line-multi)          ;; needed by consult-line to detect isearch

        ;; Minibuffer history
        :map minibuffer-local-map
        ("M-s"       . consult-history)             ;; orig. next-matching-history-element
        ("M-r"       . consult-history))                 ;; orig. previous-matching-history-element

       :config
       (setq register-preview-delay 0.5
             register-preview-function 'consult-register-format)
       (add-to-list 'consult-buffer-sources 'consult-source-point-register 'append)
       (add-to-list 'consult-preview-excluded-files "\\.\\(org\\|org_archive\\)\\'")
       (setq consult-project-function (lambda (_) (projectile-project-root))))

     (general-setq xref-show-xrefs-function 'consult-xref
                   xref-show-definitions-function 'consult-xref)

     (eval-after-load "em-hist"
       (general-define-key
        :keymaps 'eshell-hist-mode-map
        "M-r" 'consult-history))

     (defun consult--point-register-p (reg)
       "Return non-nil if REG is a point register."
       (markerp (cdr reg)))

     (defvar consult-source-point-register
       `(:name     "Point Register"
                   :narrow   (?r . "Register")
                   :category consult-location
                   :state
                   ,(lambda ()
                      (let ((state (consult--jump-state)))
                        (lambda (action cand)
                          (funcall state action (and cand (car (consult--get-location cand)))))))
                   :enabled
                   ,(lambda () (seq-some #'consult--point-register-p register-alist))
                   :items
                   ,(lambda () (consult-register--candidates #'consult--point-register-p)))
       "Point register source.")

     (use-package embark
       :ensure t
       :bind
       ((("C-;" . embark-act)
         :map embark-file-map
         ("S" . sudo-edit))))

     (use-package embark-consult
       :ensure t
       :hook
       (embark-collect-mode . consult-preview-at-point-mode))

     (use-package nerd-icons-corfu
       :ensure t
       :autoload (nerd-icons-corfu-formatter))

     ;; completion in pop-up window
     (use-package corfu
       :ensure t
       :init
       (global-corfu-mode)
       (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)
       ;; Remap with Power Toys for msrdc program
       (when (eq binarin/system-type 'wsl)
         (general-define-key :keymaps 'corfu-map
                             "C-M-S-SPC" 'corfu-insert-separator)))

   #+end_src

** External shell
   #+BEGIN_SRC emacs-lisp :tangle yes
     (unless (eq system-type 'windows-nt)
       (setq shell-file-name "/bin/sh")) ;; mostly for TRAMP, should work everywhere
   #+END_SRC
** Dired
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'dired-mode-hook 'dired-hide-details-mode)
     (setq dired-dwim-target t)

     (use-package nerd-icons-dired
       :ensure t
       :hook
       (dired-mode . nerd-icons-dired-mode))

     (use-package casual
       :ensure t
       :after dired
       :bind
       (:map dired-mode-map
             ("C-o" . casual-dired-tmenu)
             ("s" . casual-dired-sort-by-tmenu)
             ("/" . casual-dired-search-replace-tmenu)))

     (autoload 'org-attach-dired-to-subtree "org-attach")
     (with-eval-after-load "dired"
         (define-key dired-mode-map
                     (kbd "C-c C-x a")
                     #'org-attach-dired-to-subtree))
   #+END_SRC

** Magit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package magit
       :ensure t
       :commands (magit-git-insert)
       :bind
       (("C-x g" . magit-status)))
   #+END_SRC

** Undo
   #+begin_src emacs-lisp :tangle yes
     (use-package undo-tree
       :ensure t
       :config
       (global-undo-tree-mode 1))

     (general-define-key "C-M-s-?" 'winner-undo)
   #+end_src
** Saving and backups
   Save backups to one place and don't clutter filesystem with files ending in ~\~~ or ~#~.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar binarin/backups-directory (cache-file-name "backup/"))
     (make-directory binarin/backups-directory t)

     (defun home-file-regexp (&rest components)
       (s-concat "\\`" (expand-file-name (file-name-concat "~/" components))))

     (setq backup-directory-alist
           `(("." . ,binarin/backups-directory)))

     (defvar binarin/undo-tree-history-directory (cache-file-name "undo-tree/"))
     (make-directory binarin/undo-tree-history-directory t)
     (general-setq undo-tree-history-directory-alist
                   `(("." . ,binarin/undo-tree-history-directory)))

     (defvar binarin/auto-save-directory (cache-file-name "auto-save/"))
     (make-directory binarin/auto-save-directory t)
     (setq auto-save-file-name-transforms
           `((".*" ,binarin/auto-save-directory t)))

     (setq auto-save-default nil)
     (setq make-backup-files nil)
     (general-setq undo-tree-auto-save-history nil)

     (defun binarin/maybe-enable-autosave ()
       (when (or (not buffer-file-name) ;; there is some magic for saving incomlete emails etc. without a buffer. let's assume there is no sensitive information in here
                 (s-matches? (s-concat "\\`" (expand-file-name "~")) ;; and then only the contents of $HOME should be backed up
                             buffer-file-name))
         (setq-local make-backup-files t)
         (setq-local auto-save-default t)
         (general-setq-local undo-tree-auto-save-history t)))

     (add-hook 'find-file-hook 'binarin/maybe-enable-autosave)
     (add-hook 'after-set-visited-file-name-hook 'binarin/maybe-enable-autosave)
   #+END_SRC

   Never delete backup files and never re-use them (this generates
   ~200 megs per year with my usage patterns), they can help to
   recover from a lot of fuckups like ~git reset --hard~:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq version-control t)
     (setq delete-old-versions -1)
   #+END_SRC

   The fact that file is under version control is no reason to exclude
   it from this backup scheme (hello again, ~git reset --hard~):
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq vc-make-backup-files t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (global-auto-revert-mode +1)
   #+END_SRC

   #+begin_src emacs-lisp :tangle yes
     (defun binarin/setup-gpg-maybe ()
       (when (and buffer-file-name (string-match epa-file-name-regexp buffer-file-name))
         (message "Backup inhibited for this file")
         (setq-local backup-inhibited t)
         (auto-save-mode -1)
         (when (fboundp 'undo-tree-mode)
           (with-suppressed-warnings ((unresolved undo-tree-mode))
             (undo-tree-mode -1)))))

     (add-hook 'find-file-hook 'binarin/setup-gpg-maybe)
   #+end_src
** Mark
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mark-ring-max 64
           set-mark-command-repeat-pop t
           global-mark-ring-max 64)
   #+END_SRC
** Whitespace handling
   #+BEGIN_SRC emacs-lisp :tangle yes
     (general-define-key "M-SPC" 'cycle-spacing)
     (setq-default indent-tabs-mode nil)

     (defun binarin/show-trailing-whitespace ()
       (setq show-trailing-whitespace t))
     (add-hook 'prog-mode-hook #'binarin/show-trailing-whitespace)

     (use-package ws-butler
       :ensure t
       :config
       (ws-butler-global-mode +1))

     (setq require-final-newline 'ask-me)
     (setq tab-always-indent 'complete)
   #+END_SRC
** Killing
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq kill-do-not-save-duplicates t
           kill-ring-max 256)
   #+END_SRC
** Clipboard
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq save-interprogram-paste-before-kill t)
     (use-package clipetty
       :ensure t
       :hook (after-init . global-clipetty-mode))
   #+END_SRC
** Bookmarks
   Save bookmarks every time bookmark is modified
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq bookmark-save-flag 1)
   #+END_SRC
** Narrowing
   #+BEGIN_SRC emacs-lisp :tangle yes
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC
** Line numbers
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq line-number-display-limit-width 1000)
   #+END_SRC

** Search
   #+BEGIN_SRC emacs-lisp
     (setq isearch-allow-scroll t
           search-ring-max 128
           regexp-search-ring-max 128)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/search-words ()
       (interactive)
       (when (use-region-p)
         (browse-url
          (concat "https://duckduckgo.com/html/?q="
        	     (url-hexify-string (buffer-substring (region-beginning) (region-end)))))))

     (general-define-key "M-s M-w" 'binarin/search-words)
   #+END_SRC

** Automatically make scripts executable
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'after-save-hook
               'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC
** Window handling
   Prefer horizontal splits:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq split-width-threshold 100)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (winner-mode)
   #+END_SRC
** I18n
*** Extra keybinding for niri integration

    Didn't found a way to bind ~Ctrl+\\~ in niri, an still be able to send
    the same combination to emacs.
    #+begin_src emacs-lisp :tangle yes
      (global-set-key (kbd "C-M-s-|") 'toggle-input-method)
    #+end_src

*** Prefer Russian and UTF-8
    #+begin_src emacs-lisp :tangle yes
      (set-language-environment "Russian")
      (setq default-input-method "russian-computer")
      (prefer-coding-system 'utf-8-unix)
    #+end_src

** Server
   #+begin_src emacs-lisp :tangle yes
     (require 'server)

     ;; don't try starting server if it's already running in another instance
     (defun binarin/server-start ()
       (unless (server-running-p server-name)
         (server-start)))

     (add-hook 'after-init-hook #'binarin/server-start)
   #+end_src

** TRAMP
   #+begin_src emacs-lisp :tangle yes
     (use-package tramp
       :functions tramp-compile-disable-ssh-controlmaster-options)

     (eval-after-load "tramp"
       (general-setq tramp-login-prompt-regexp ".*\\(user\\|login\\|2FA Token\\)\\( .*\\)?: *"))

     (general-setq
      remote-file-name-inhibit-delete-by-moving-to-trash t
      tramp-use-scp-direct-remote-copying t
      remote-file-name-inhibit-auto-save-visited t
      tramp-copy-size-limit (* 1024 1024) ;; 1MB
      tramp-verbose 2)

     (setq vc-ignore-dir-regexp
           (format "\\(%s\\)\\|\\(%s\\)"
                   vc-ignore-dir-regexp
                   tramp-file-name-regexp))

     (connection-local-set-profile-variables
      'remote-direct-async-process
      '((tramp-direct-async-process . t)))

     (connection-local-set-profiles
      '(:application tramp :protocol "scp")
      'remote-direct-async-process)

     (setq magit-tramp-pipe-stty-settings 'pty)

     (with-eval-after-load 'tramp-sh
       (setq tramp-remote-path
             (append tramp-remote-path
     	        '(tramp-own-remote-path))))

     (with-eval-after-load 'tramp
       (with-eval-after-load 'compile
         (remove-hook 'compilation-mode-hook #'tramp-compile-disable-ssh-controlmaster-options)))
   #+end_src
** Direnv
   #+begin_src emacs-lisp :tangle yes
     (use-package direnv
       :ensure t
       :if (not (eq system-type 'windows-nt))
       :config
       (direnv-mode)
       (advice-add 'direnv--summarise-changes :around 'binarin/cleanup_direnv--summarise-changes)
       (add-to-list 'warning-suppress-types '(direnv))
       :custom
       ((direnv-always-show-summary t)
        (direnv-show-paths-in-summary nil)))

     (defvar binarin/direnv-boring-items
       '(
         "AR"
         "AS"
         "CC"
         "CONFIG_SHELL"
         "CXX"
         "DETERMINISTIC_BUILD"
         "DEVELOPER_DIR"
         "DEVENV_DOTFILE"
         "DEVENV_STATE"
         "HOST_PATH"
         "IN_NIX_SHELL"
         "LD"
         "LD_DYLD_PATH"
         "MACOSX_DEPLOYMENT_TARGET"
         "NM"
         "OBJCOPY"
         "OBJDUMP"
         "PATH_LOCALE"
         "RANLIB"
         "READELF"
         "SDKROOT"
         "SIZE"
         "SOURCE_DATE_EPOCH"
         "STRINGS"
         "STRIP"
         "XDG_DATA_DIRS"
         "XML_CATALOG_FILES"
         "XPC_SERVICE_NAME"
         "ZERO_AR_DATE"
         ))

     (defun binarin/cleanup_direnv--summarise-changes (orig-fun items)
       (funcall orig-fun (-remove (lambda (elt)
                                    (or
                                     (let ((case-fold-search nil))
                                       (s-matches? (rx bol (or lower "_" "PYTHON" "NIX_"))
                                                   (car elt)))
                                     (-elem-index (car elt) binarin/direnv-boring-items)))
                                  items)))

   #+end_src
** Local variables
   #+begin_src emacs-lisp :tangle yes
     (setq safe-local-variable-directories
           (-map #'expand-file-name '("~/personal-workspace/nixos-config/files"
                                      "~/personal-workspace/nixos-config/ansible"
                                      "~/finance")))

     (setq safe-local-variable-values
           '((compile-command . "tangle-emacs-org-babel-config emacs-config.org /tmp/")))

     (add-to-list 'safe-local-eval-forms '(add-hook 'after-save-hook 'recompile 98 t))
   #+end_src
** Uniquify buffer names
   #+begin_src emacs-lisp :tangle yes
     ;; Yo dawg! I heard you like advices so I added an advice around your advice

     (defun binarin/augment-buffer-name (filename basename)
       (when (and filename
                  (s-matches? (rx bol (or "default.nix" "package.nix" "baseline.nix" "config.kdl") eol) (file-name-nondirectory filename)))
         (setf basename (format "%s{%s}"
                                basename
                                (file-name-nondirectory (s-chop-suffix "/" (file-name-parent-directory filename))))))

       (awhen (and filename
                   (projectile-project-root (file-name-directory filename)))
         (setf basename (s-concat basename "(" (projectile-project-name it) ")")))

       basename)

     (defun binarin/uniquify--create-file-buffer-advice-advice (orig-fun buf filename basename)
       (funcall orig-fun buf filename (binarin/augment-buffer-name filename basename)))

     (advice-add 'uniquify--create-file-buffer-advice :around 'binarin/uniquify--create-file-buffer-advice-advice)

     (defun binarin/uniquify--rename-buffer-advice-advice (orig-fun newname &optional unique)
       (funcall orig-fun newname;; (binarin/augment-buffer-name (buffer-file-name) newname)
                unique))

     (advice-add 'uniquify--rename-buffer-advice :around 'binarin/uniquify--rename-buffer-advice-advice)
   #+end_src
** Eat
   #+begin_src emacs-lisp :tangle yes
     (use-package eat
       :ensure t
       :commands (eat))
   #+end_src
** vterm
   #+begin_src emacs-lisp :tangle yes
     (use-package vterm
       :ensure t
       :commands (vterm vterm-send-string vterm-send-return)
       :no-require t
       :custom
       ((vterm-shell "zsh")))

     (defvar binarin/vterm-frame-counter 0)

     (defun binarin/new-vterm-frame ()
       (let ((frame (make-frame)))
         (with-selected-frame frame
           (let ((vterm-buffer (vterm (format "*vterm-%s*" (format "vterm-frame-%d" (cl-incf binarin/vterm-frame-counter))))))
             (switch-to-buffer vterm-buffer)
             (delete-other-windows)))))


   #+end_src
** Auth
   #+begin_src emacs-lisp :tangle yes
     (awhen (executable-find "gopass")
       (general-setq auth-source-pass-filename (s-trim (shell-command-to-string "gopass config mounts.path")))
       (auth-source-pass-enable))
   #+end_src
** Expanding region
   #+begin_src emacs-lisp :tangle yes
     (use-package expreg
       :ensure t
       :bind
       (("C-=" . expreg-expand)
        ("C-S-=" . expreg-contract)))
   #+end_src
** Bell
   #+begin_src emacs-lisp :tangle yes
     (setf visible-bell t)
     (awhen (eq binarin/system-type 'darwin)
       (setq ring-bell-function 'ignore))

     (use-package mode-line-bell
       :ensure t)
     (mode-line-bell-mode)

   #+end_src
* Programming
** Snippets
   #+begin_src emacs-lisp :tangle yes
     (use-package yasnippet
       :ensure t
       :autoload yas-minor-mode snippet-mode
       :config
       (when (file-directory-p "~/personal-workspace/nixos-config")
         (setf yas-snippet-dirs '("~/personal-workspace/nixos-config/files/yasnippets"))))
   #+end_src

** Projects
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package projectile
       :ensure t
       :commands (projectile-make-relative-to-root projectile-project-root projectile-project-name)
       :bind-keymap
       ("C-c p" . projectile-command-map)
       :config
       (setq projectile-keymap-prefix (kbd "C-c p"))
       (setq projectile-enable-caching nil)
       (setq projectile-completion-system 'default)
       ;; For my projects I usually don't want to include submodules in file
       ;; list. And anyway, this is broken for some of the things I work on
       ;; (e.g. it fails on submodules without url).
       (setq projectile-git-submodule-command nil)
       (projectile-mode +1))

     (use-package projectile-ripgrep
       :ensure t
       :commands (projectile-ripgrep))
   #+END_SRC

** LSP
   #+begin_src emacs-lisp :tangle yes
     (use-package lsp-mode
       :ensure t
       :init
       (setq lsp-keymap-prefix "C-c l")
       :commands (lsp lsp-deferred))

     (add-hook 'lsp-mode-hook 'electric-indent-local-mode)
     (add-hook 'lsp-mode-hook 'electric-pair-local-mode)
     (add-hook 'lsp-mode-hook 'electric-quote-local-mode)
     (add-hook 'lsp-mode-hook 'electric-layout-local-mode)
     (add-hook 'lsp-mode-hook 'yas-minor-mode)
   #+end_src
** Perl
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defalias 'perl-mode 'cperl-mode)
     (general-setq cperl-hairy t
     	      cperl-indent-level 4
     	      cperl-indent-parens-as-block t
     	      cperl-close-paren-offset -4)
     (add-hook 'cperl-mode-hook 'ws-butler-mode)
   #+END_SRC

** Lisp
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package paredit
       :ensure t
       :hook
       (emacs-lisp-mode                  . paredit-mode)
       (emacs-data-mode                  . paredit-mode)
       (lisp-mode                        . paredit-mode)
       (lisp-interaction-mode            . paredit-mode)
       (eval-expression-minibuffer-setup . paredit-mode)
       :bind
       (:map paredit-mode-map
             ("RET" . paredit-newline)
             ("C-j" . nil)))
   #+END_SRC

   Doesn't play good with paredit.
   #+begin_src emacs-lisp :tangle yes
     (electric-indent-mode -1)
   #+end_src

** Nix
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package nix-mode
       :ensure t
       :mode "\\.nix\\'")
   #+END_SRC
** Share source position
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/get-git-remote-urls ()
       (with-temp-buffer
         (magit-git-insert "remote" "-v")
         (-remove #'null (-map #'(lambda (a) (nth 1 (s-split "[ \t]+" a))) (s-lines (buffer-string))))))

     (defun binarin/get-head-commit-sha ()
       (with-temp-buffer
         (magit-git-insert "rev-parse" "HEAD")
         (s-trim (buffer-string))))

     (defun binarin/make-gitlab-link (base project)
       (let ((commit-sha (binarin/get-head-commit-sha))
             (filename-relative (car (projectile-make-relative-to-root (list (buffer-file-name)))))
             (line-number (string-to-number (format-mode-line "%l"))))
         (format "https://%s/%s/blob/%s/%s#L%d" base project commit-sha filename-relative line-number)))

     (defun binarin/make-github-link (project)
       (let ((commit-sha (binarin/get-head-commit-sha))
             (filename-relative (car (projectile-make-relative-to-root (list (buffer-file-name)))))
             (line-number (string-to-number (format-mode-line "%l"))))
         (format "https://%s/%s/blob/%s/%s#L%d" "github.com" project commit-sha filename-relative line-number)))

     (defun binarin/open-web-link-to-source-code ()
       (interactive)
       (require 'magit)
       (aif (cl-block loop
              (dolist (url (binarin/get-git-remote-urls))
                (acond
                 ((s-match  "\\(gitlab\\.[^/:]+\\)[:/]\\(.*?\\)\\(\\.git\\)?$" url)
                  (cl-return-from loop (binarin/make-gitlab-link (nth 1 it) (nth 2 it))))
                 ((or
                   (s-match "https://github.com/\\(.*\\)" url)
                   (s-match "git@github.com:\\(.*\\)" url))
                  (cl-return-from loop (binarin/make-github-link (nth 1 it)))))))
           (browse-url it)
         (message "Failed to generate a link from that file")))
   #+END_SRC
** YAML
   #+begin_src emacs-lisp :tangle yes
     (use-package yaml-mode
       :ensure t
       :mode "\\.\\(yaml\\|yml\\)\\'")
   #+end_src
** Nushell
   #+begin_src emacs-lisp :tangle yes
     (use-package nushell-mode
       :ensure t
       :mode "\\.nu\\'")
   #+end_src
** Docker
   #+begin_src emacs-lisp :tangle yes
     (use-package dockerfile-mode
       :ensure t
       :mode "/Dockerfile")
   #+end_src
** Ansible
   #+begin_src emacs-lisp :tangle yes
     (use-package ansible
       :ensure t
       :commands (ansible-mode))
   #+end_src
** Open git-backed files in browser
   #+begin_src emacs-lisp :tangle yes
     (use-package browse-at-remote
       :ensure t
       :bind
       (("C-c g g" . browse-at-remote)))
   #+end_src
** Dhall
   #+begin_src emacs-lisp :tangle yes
     (use-package dhall-mode
       :ensure t
       :mode "\\.dhall\\'")
   #+end_src
** Rust
   #+begin_src emacs-lisp :tangle yes
     (use-package rust-mode
       :ensure t
       :mode "\\.rs\\'")
   #+end_src
** Just
   #+begin_src emacs-lisp :tangle yes
     (use-package just-mode
       :ensure t
       :mode "/justfile\\'")
   #+end_src
** Markdown
   #+begin_src emacs-lisp :tangle yes
     (use-package markdown-mode
       :ensure t
       :mode "\\.md\\'$")

     (use-package edit-indirect
       :ensure t
       :defer t)

     (with-eval-after-load 'markdown-mode
       (load-library "edit-indirect"))
   #+end_src
** Javascript
   #+begin_src emacs-lisp :tangle yes
     (use-package js2-mode
       :ensure t
       :mode "\\.js\\'$")
   #+end_src
** SQLite
   #+begin_src emacs-lisp :tangle yes
     (defun sqlite-handler (operation &rest args)
       (ignore operation)
       (kill-buffer nil)
       (sqlite-mode-open-file (car args)))

     (put 'sqlite-handler 'operations '(insert-file-contents))

     (add-to-list 'file-name-handler-alist
                  '("\\.sqlite\\'" . sqlite-handler))
   #+end_src
** Compilation
   #+begin_src emacs-lisp :tangle yes
     (use-package fancy-compilation
       :ensure t
       :hook
       (compilation-mode-hook . fancy-compilation-mode))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defvar binarin/after-compilation-armed t)
     (defvar binarin/after-compilation-commands (make-hash-table :test 'equal))
     (defvar binarin/project-bazel-target (make-hash-table :test 'equal))

     (add-to-list
      'display-buffer-alist
      `(,(rx (or "*compilation*" (seq "*project-vterm:" (1+ anychar) "*")))
        . (display-buffer-reuse-window
           . ((reusable-frames . t)))))

     ;; (general-define-key "<f9>" 'binarin/bazel-compile-and-run)
     (general-define-key "<f9>" 'recompile)


     (defun binarin/all-bazel-targets ()
       (let ((default-directory (projectile-project-root)))
         (when (and default-directory (file-exists-p "MODULE.bazel"))
           (cl-remove-if-not #'(lambda (s) (s-starts-with? "//" s)) (process-lines "bazel" "query" "//...:all")))))

     (defun binarin/is-bazel-project (project-dir)
       (file-exists-p (expand-file-name "MODULE.bazel" project-dir)))

     (defun binarin/bazel-compile-and-run (target)
       (interactive
        (let (project-dir current-target)
          (setf project-dir (projectile-project-root))
          (when (not project-dir) (error "Can't find project root"))
          (when (not (binarin/is-bazel-project project-dir)) (error "Not a bazel project"))
          (setf current-target (gethash (projectile-project-root) binarin/project-bazel-target))
          (if (or current-prefix-arg (not current-target))
              (list (completing-read "Pick bazel target: " (binarin/all-bazel-targets)))
            (list current-target))))
       (let ((project-dir (projectile-project-root))
             (bazel-build (concat "bazel build " target))
             (bazel-run (concat "bazel run " target)))
         (setf (gethash project-dir binarin/after-compilation-commands) bazel-run)
         (setf (gethash project-dir binarin/project-bazel-target) target)
         (setf compile-command bazel-build)
         (setf compilation-directory project-dir)
         (binarin/recompile-and-run)))

     (autoload 'recompile "compile")
     (defun binarin/recompile-and-run ()
       (interactive)
       (setf binarin/after-compilation-armed t)
       (recompile))

     (defun run-in-vterm-kill (process event)
       "A process sentinel. Kills PROCESS's buffer if it is live."
       (ignore event)
       (let ((b (process-buffer process)))
         (and (buffer-live-p b)
              (kill-buffer b))))

     (defun binarin/run-project-command (project-dir command)
       (let ((default-directory project-dir)
             (vterm-name (concat "*project-vterm:" project-dir "*")))
         (with-current-buffer (or (get-buffer vterm-name)
                                  (vterm vterm-name))
           (with-suppressed-warnings ((free-vars vterm--process))
             (set-process-sentinel vterm--process #'run-in-vterm-kill)) ;; XXX
           (vterm-send-string command)
           (vterm-send-return))))

     (defun binarin/maybe-run-after-compilation (comp-buffer msg)
       (interactive)
       (when binarin/after-compilation-armed
         (setf binarin/after-compilation-armed nil)
         (when (s-contains? "finished" msg)
           (let ((project (with-current-buffer comp-buffer (projectile-project-root))))
             (when project
               (let ((command (gethash project binarin/after-compilation-commands)))
                 (when command
                   (binarin/run-project-command project command))))))))

     (add-hook 'compilation-finish-functions 'binarin/maybe-run-after-compilation)
   #+end_src
** Git
   #+begin_src emacs-lisp :tangle yes
     (use-package git-link
       :ensure t
       :commands (git-link git-link-commit git-link-homepage))
   #+end_src
** Bazel
   #+begin_src emacs-lisp :tangle yes
     (use-package bazel
       :ensure t
       :defer t
       :commands (bazel-build-mode bazel-module-mode bazel-starlark-mode bazelrc-mode bazelignore-mode bazeliskrc-mode))

     (-each (list (cons (rx ?/ (or "BUILD" "BUILD.bazel")) 'bazel-build-mode)
                                 (cons (rx ?/ (or "WORKSPACE" "WORKSPACE.bazel" "WORKSPACE.bzlmod")
                                           eos)
                                       'bazel-workspace-mode)
                                 (cons (rx "/MODULE.bazel" eos) 'bazel-module-mode)
                                 (cons (rx ?/ (+ nonl) ".bzl" eos) 'bazel-starlark-mode)
                                 (cons (rx ?/ (or "bazel.bazelrc" ".bazelrc") eos) 'bazelrc-mode)
                                 (cons (rx "/.bazelignore" eos) 'bazelignore-mode)
                                 (cons (rx "/.bazeliskrc" eos) 'bazeliskrc-mode))
       (lambda (elt) (add-to-list 'auto-mode-alist elt)))

   #+end_src
** C/C++
   #+begin_src emacs-lisp :tangle yes
     (add-to-list
      'auto-mode-alist
      (cons (rx "."
                       (submatch (any "ch"))
                       (or "++" "xx" "pp" (backref 1))
                       string-end)
            'c++-ts-mode))
   #+end_src
** Jinja2
   #+begin_src emacs-lisp :tangle yes
     (use-package jinja2-mode
       :ensure t
       :mode "\\.j2\\'")
   #+end_src
** CMake
   #+begin_src emacs-lisp :tangle yes
     (use-package cmake-mode
       :ensure t
       :mode "\\(CMakeLists.txt\\|\\.cmake\\)\\'")
   #+end_src
** Lua
   #+begin_src emacs-lisp :tangle yes
     (use-package lua-mode
       :ensure t
       :mode "\\.lua\\'")
   #+end_src
** PowerShell
   #+begin_src emacs-lisp :tangle yes
     (use-package powershell
       :ensure t
       :mode "\\.ps1\\'")
   #+end_src
** OpenSCAD
   #+begin_src emacs-lisp :tangle yes
     (use-package scad-mode
       :ensure t
       :mode "\\.scad\\'")
   #+end_src
** Haskell
   #+begin_src emacs-lisp :tangle yes
     (use-package haskell-mode
       :ensure t
       :mode "\\.hs\\'")
   #+end_src

** ledger/hledger
 #+begin_src emacs-lisp :tangle yes
   (use-package ledger-mode
     :ensure t
     :autoload ledger-context-at-point
     :mode ("\\.hledger\\'" "\\.ledger\\'" "\\.journal\\'"))

   (general-setq
    ledger-post-amount-alignment-column 70
    ledger-mode-should-check-version nil
    ledger-report-auto-width nil
    ledger-report-links-in-register nil
    ledger-report-native-highlighting-arguments '("--color=always")
    ledger-default-date-format "%Y-%m-%d"
    ledger-reconcile-default-date-format "%Y-%m-%d")
 #+end_src

*** Interface for resolving transactions (on top of transient)

#+INCLUDE: "./pta.el" src emacs-lisp :tangle yes

** KMonad/Kanata .kbd files
   #+begin_src emacs-lisp :tangle yes
     (use-package kbd-mode
       :mode ("\\.kbd\\'" . kbd-mode))
   #+end_src

** KDL mode
   #+begin_src emacs-lisp :tangle yes
     (use-package kdl-mode
       :ensure t
       :no-require t
       :mode "\\.kdl\\'")

     (defun binarin/kdl-mode-hook ()
       (setf tab-width 2))

     (add-hook 'kdl-mode-hook 'binarin/kdl-mode-hook)
   #+end_src

** AI coding
   #+begin_src emacs-lisp :tangle yes
     (use-package agent-shell
       :commands (agent-shell-make-environment-variables agent-shell-anthropic-make-authentication)
       :ensure t)

     (setq agent-shell-anthropic-claude-environment
           (agent-shell-make-environment-variables :inherit-env t))

     (setq agent-shell-anthropic-authentication
           (agent-shell-anthropic-make-authentication :login t))
   #+end_src
** ZMK
   #+begin_src emacs-lisp :tangle yes
     (use-package devicetree-ts-mode
       :ensure t
       :mode "\\.keymap\\'"
       :config
       (add-hook 'devicetree-ts-mode-hook 'yas-minor-mode)
       (define-key devicetree-ts-mode-map (kbd "C-c C-i") 'binarin/indent-zmk-layer))

     (defun binarin/indent-zmk-layer ()
       (interactive)
       (let (beg end)
         (save-excursion
           (beginning-of-line)
           (while (not (looking-at (rx (* space) "bindings" (* space) "=" (* space) "<") t))
             (forward-line -1))
           (forward-line)
           (beginning-of-line)
           (setf beg (point))
           (re-search-forward ">;")
           (forward-line -1)
           (end-of-line)
           (setf end (point))
           (align-regexp beg end (rx (not (any " \n")) (group (+ " ")) (not (any " \n"))) 1 1 t))))

   #+end_src
* Major modes
** pdf-tools
   #+begin_src emacs-lisp :tangle yes
     (use-package pdf-tools
       :ensure t
       :autoload pdf-loader-install)

     (pdf-loader-install)
   #+end_src
* Org mode
** Load modules
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; XXX Use consult for clock-in

     (run-with-idle-timer 10 nil (lambda () (load-library "org")))

     (use-package org
       :ensure t
       :commands (org-save-all-org-buffers)
       :defines (org-capture-templates
                org-archive-subtree-save-file-p
                org-clock-idle-time
                org-clock-auto-clockout-timer)
       :mode ("\\.org\\'" . org-mode)
       :bind
       (("C-c a" . org-agenda)
        ("C-c r" . org-capture))
       :config
       (setq org-archive-location "archive.org::* From %s")
       (define-key org-mode-map
                   (kbd "C-c [")
                   'binarin/org-agenda-file-to-front)

       (define-key org-mode-map
                   (kbd "C-c ]")
                   'binarin/org-remove-file)
       (setq org-agenda-files (-map #'f-expand
                                    (-filter #'f-exists?
                                             '("~/org/personal.org"
                                               "~/org/contacts.org"
                                               "~/org/caldav.org"
                                               "~/org/archive.org"
                                               "~/org/maybe.org"
                                               "~/org/refile.org"
                                               "~/org/ference.org")))
             org-directory "~/org"))

     (general-setq org-attach-id-dir (file-name-as-directory (expand-file-name "~/org/data")))

     ;; don't try to save, init.el is in nix store and is read-only
     (defun binarin/org-agenda-file-to-front (&optional to-end)
       (interactive "P")
       (let ((user-init-file nil))
         (org-agenda-file-to-front to-end)))

     (defun binarin/org-remove-file (&optional file)
       (interactive)
       (let ((user-init-file nil))
         (org-remove-file file)))


     (use-package org-contrib
       :ensure t
       :defer)

     (with-eval-after-load 'org-mouse
       (setf (symbol-function 'org--mouse-open-at-point) #'(lambda (orig-fun &rest args) (apply orig-fun args))))
   #+END_SRC
** Todo keywords
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; ! - log timestamp
     ;; @ - log timestamp and note
     ;; !/! - also log when leaving state
     (setq org-todo-keywords
           '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
             (type "|" "CNCL(c!)")
             (type "WAIT(w!/!)" "|")))

     (with-no-warnings
       (zenburn-with-color-variables
         (setq org-todo-keyword-faces
               `(("TODO" :foreground ,zenburn-red :weight bold)
                 ("NEXT" :foreground ,zenburn-cyan :weight bold)
                 ("DONE" :foreground ,zenburn-green-3 :weight bold)
                 ("WAIT" :foreground ,zenburn-orange :weight bold)
                 ("CNCL" :foreground ,zenburn-green-3 :weight bold)))))

     (setq org-enforce-todo-dependencies t)
     (setq org-enforce-todo-checkbox-dependencies t)

     (setq org-log-done 'time)
     (setq org-log-into-drawer t)
   #+END_SRC

** Tags
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-fast-tag-selection-single-key 't)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-tags-exclude-from-inheritance '("PROJ"))
     (setq org-tag-alist `((:startgroup . nil)
                           ("@home" . ?h)
                           ("@errand" . ?e)
                           ("@zolder" . ?z)
                           (:endgroup . nil)
                           (:startgroup . nil)
                           ("PROJ" . ?p)
                           (:endgroup . nil)))
   #+END_SRC

** Outline
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; First C-a/C-e goes to line end/start, second time - to heading text start/end
     (setq org-special-ctrl-a/e 'reversed)

     ;; C-k becomes aware of heading structure, i.e. it can kill heading text up to tags
     (setq org-special-ctrl-k 't)

     (setq org-startup-folded t)

     (setq org-cycle-separator-lines 0)

     (setq org-fold-catch-invisible-edits 'show-and-error)

     (general-setq org-goto-interface 'outline-path-completion)

     (setq org-adapt-indentation t)

     (setq org-yank-adjusted-subtrees t)
     (setq org-yank-folded-subtrees t)

     (setq org-columns-default-format "%TODO %80ITEM %CLOCKSUM %CLOCKSUM_T %TAGS")
   #+END_SRC

** Agenda
   #+begin_src emacs-lisp :tangle yes
     (use-package htmlize
       :defer t
       :ensure t)

     (setq org-agenda-dim-blocked-tasks nil)
     (setq org-deadline-warning-days 15)
     (setq org-agenda-hide-tags-regexp (rx (or "PROJ" "agenda_hide")))

     (setq org-agenda-sorting-strategy '((agenda habit-down time-up urgency-down tag-up category-up)
                                         (todo urgency-down tag-up category-up)
                                         (tags urgency-down tag-up category-up)
                                         (search category-keep)))

     (defvar binarin/agenda-prepend-parent nil)

     (defun binarin/agenda-item-prepend-parent (item)
       (let ((marker (org-find-text-property-in-string 'org-marker item)))
         (when (markerp marker)
           (org-with-point-at marker
             (awhen (and (= 3 (org-current-level)) (org-up-heading-safe)
                         (org-entry-get nil "ITEM"))
               (set-text-properties 0 (length it) nil it)
               (setf item (replace-regexp-in-string (rx (or "NEXT" "WAIT") (group any) (* any) eos)
                                                    (propertize (s-concat " [" it "] ")
                                                                'face 'org-agenda-dimmed-todo-face)
                                                    item nil nil 1)))))
         item))

     (defun binarin/org-agenda-finalize-prepend-parent (string)
       (if (not binarin/agenda-prepend-parent)
           string
         (--> string
              (split-string it "\n" 'omit-nulls)
              (-map 'binarin/agenda-item-prepend-parent it)
              (s-join "\n" it))))


     (advice-add 'org-agenda-finalize-entries :filter-return 'binarin/org-agenda-finalize-prepend-parent)

     (defun binarin/org-agenda-after-show-reveal ()
       (org-reveal)
       (cl-case (org-current-level)
         (2 (when (member "PROJ" (org-get-tags))
              (recenter-top-bottom 0)
              (org-fold-hide-subtree)
              (org-fold-show-children)))
         (3 (let ((old-point (point)))
              (org-up-heading-safe)
              (recenter-top-bottom 0)
              (org-fold-hide-subtree)
              (org-fold-show-children)
              (goto-char old-point)
              (org-fold-show-entry)))))

     (add-hook 'org-agenda-after-show-hook 'binarin/org-agenda-after-show-reveal)

     (setq org-agenda-custom-commands '(("a" "Agenda and NEXTs" ((agenda "")
                                                                 (todo "NEXT" ())
                                                                 (stuck "" ()))
                                         ((binarin/agenda-prepend-parent t)
                                          (org-agenda-compact-blocks t)
                                          (org-fold-show-context-detail '((agenda . local))))
                                         ("~/org/export/agenda.html"))
                                        ("w" "WAIT"
                                         todo "WAIT"
                                         ((binarin/agenda-prepend-parent t))
                                         ("~/org/export/wait.html"))
                                        ("z" "@zolder"
                                         tags-todo "+@zolder+TODO=\"NEXT\""
                                         ((binarin/agenda-prepend-parent t)
                                          (org-agenda-hide-tags-regexp "@zolder"))
                                         ("~/org/export/zolder.html"))
                                        ("e" "@errand"
                                         tags-todo "+@errand+TODO=\"NEXT\""
                                         ((binarin/agenda-prepend-parent t)
                                          (org-agenda-hide-tags-regexp "@errand"))
                                         ("~/org/export/errand.html"))
                                        ("r" "REFILE" tags "REFILE")))

     (general-setq org-agenda-include-diary nil)
     (general-setq org-agenda-span 'day)
     (general-setq org-agenda-start-on-weekday 1)
     (general-setq org-agenda-window-setup 'only-window)
     (general-setq org-agenda-compact-blocks t)
     (general-setq org-agenda-block-separator nil)
     (general-setq org-agenda-skip-scheduled-if-done t)
     (general-setq org-agenda-skip-deadline-if-done t)
     (general-setq org-agenda-skip-timestamp-if-done t)

     (setq
      ;; Agenda styling
      org-agenda-block-separator ?
      org-agenda-time-grid
      '((daily today require-timed)
        (800 1000 1200 1400 1600 1800 2000)
        "  " "")
      org-agenda-current-time-string
      " now ")
   #+end_src

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-agenda-tags-column 'auto
           org-tags-column -124
           org-auto-align-tags t
           org-insert-heading-respect-content t
           org-hide-emphasis-markers nil
           org-pretty-entities t)
   #+END_SRC
** Templates
   #+BEGIN_SRC emacs-lisp :tangle yes
     (eval-after-load 'org
       (lambda ()
         (require 'org-tempo)
         (add-to-list 'org-structure-template-alist '("m" . "src emacs-lisp :tangle yes"))))
   #+END_SRC
** Priorities
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-highest-priority ?A
           org-lowest-priority ?D
           org-default-priority ?D)
   #+END_SRC
** Contacts
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package org-contacts
       :ensure t
       :after (org)
       :config
       (setq org-contacts-files '("~/org/contacts.org")))
   #+END_SRC

** Appearance
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/org-agenda-mode-hook ()
       ;; Always highlight the current agenda line
       (hl-line-mode 1))

     (add-hook 'org-agenda-mode-hook
               'binarin/org-agenda-mode-hook
               'append)
   #+END_SRC

   #+begin_src emacs-lisp :tangle yes
     (general-setq org-use-sub-superscripts '{}
                   org-export-with-sub-superscripts '{})
   #+end_src
** Capture
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-capture-templates
           '(("t" "todo" entry
              (file "~/org/refile.org")
              "* %?\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :CREATED: %U\n  :END:\n"
              :clock-in t :clock-resume t)
             ("n" "comment on clocked" plain
              (clock)
              "%?")
             ("l" "Link" entry
              (file "~/org/refile.org")
              "* %a\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :CREATED: %U\n  :END:\n\n  %i" :immediate-finish t)))

     (setq org-default-notes-file "~/org/refile.org")

     (defun binarin/hide-drawers-hook ()
       (save-excursion
         (goto-char (point-min))
         (org-cycle-hide-drawers 'children)))

     (add-hook 'org-capture-mode-hook #'binarin/hide-drawers-hook)
     (add-hook 'org-capture-mode-hook #'auto-fill-mode)

     (defun binarin/org-capture-finalize-fix-properties ()
       "Fix capture buffer so that :PROPERTIES: are always first - the rest of
     the text between the heading line and :PROPERTIES: drawer gets moved to
     the end."
       (let (start extra)
         (save-excursion
           (goto-char (point-min))
           (forward-line)
           (setf start (point))
           (when (search-forward ":PROPERTIES:" nil t)
             (beginning-of-line)
             (when (> (point) start)
               (setf extra (buffer-substring start (point)))
               (delete-region start (point))
               (goto-char (point-max))
               (insert extra))))))

     (add-hook 'org-capture-prepare-finalize-hook 'binarin/org-capture-finalize-fix-properties)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (autoload 'org--protocol-detect-protocol-server "org-protocol")

     (defun org-protocol-lazy-load (orig-fun files client &rest args)
       (if (or (featurep 'org-protocol)
               (not (delq nil
                          (mapcar (lambda (loc)
                                    ;; loc: (file-name . (line . column))
                                    (string-match-p "\\(?:^\\|[/\\\\]\\)org-protocol:" (car loc)))
                                  files))))
           (apply orig-fun files client args)
         (apply #'org--protocol-detect-protocol-server orig-fun files client args)))

     (advice-add 'server-visit-files :around #'org-protocol-lazy-load)

     (autoload 'notifications-notify "notifications")
     (declare-function binarin/notifications-notify "init")
     (cond ((eq binarin/system-type 'windows)
            (setf (symbol-function 'binarin/notifications-notify)
                  (cl-function (lambda (&key title body app-name app-icon timeout urgency)
                                 (ignore app-name app-icon timeout urgency app-icon)
                                 (call-process "c:/emacs/bin/toast.exe" nil nil nil "--title" title "--message" body)))))
           ((eq binarin/system-type 'darwin)
            (setf (symbol-function 'binarin/notifications-notify)
                  (cl-function (lambda (&key title body app-name app-icon timeout urgency)
                                 (ignore app-name app-icon timeout urgency app-icon)
                                 (call-process "terminal-notifier" nil nil nil "-title" title "-message" body "-activate" "org.gnu.Emacs")))))
           (t (setf (symbol-function 'binarin/notifications-notify) (lambda (&rest args)
                                                                      (apply 'notifications-notify args)))))

     (defvar org-capture-last-stored-marker)  ; From org-capture

     (defun binarin/display-notify-after-capture (&rest args)
       (ignore args)
       (binarin/notifications-notify
        :title "Captured"
        :body (org-with-point-at org-capture-last-stored-marker
                (org-get-heading))
        :app-name "emacs"
        :app-icon (substitute-in-file-name "$XDG_DATA_HOME/icons/emacs/org.svg")
        :timeout 3000
        :urgency 'low))

     (advice-add 'org-protocol-capture :after #'binarin/display-notify-after-capture)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar binarin/org-protocol-mundane-link-descriptions
       '(" - YouTube"))

     (defun binarin/org-protocol-capture-postprocess ()
       (save-excursion
         (goto-char (point-min)))
       (awhen (s-match "binarin@binarin.ru - Mail\\]\\]" (buffer-string))
         (save-excursion
           (goto-char (point-min))
           (while (re-search-forward "https://mail\\.google\\.com/mail/u/[0-9]/" (point-max) t)
             (replace-match "https://mail.google.com/mail/u/?authuser=binarin@binarin.ru"))))
       (awhen (re-search-forward (concat (regexp-opt binarin/org-protocol-mundane-link-descriptions t) "]]") nil t) ;
         (replace-match "]]")))

     (add-hook 'org-capture-prepare-finalize-hook #'binarin/org-protocol-capture-postprocess)
   #+END_SRC
** Refile
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setf org-archive-subtree-save-file-p t)

     ;; Targets include this file and any file contributing to the agenda - up to 9 levels deep
     (setq org-refile-targets '((org-agenda-files :maxlevel . 9)
                                (nil :maxlevel . 9)))

     ;; Use full outline paths for refile targets - we file directly with IDO
     (setq org-refile-use-outline-path 'file)

     ;; Targets complete directly with IDO
     (setq org-outline-path-complete-in-steps nil)

     ;; Allow refile to create parent tasks with confirmation
     (setq org-refile-allow-creating-parent-nodes 'confirm)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/update-parent-todo-statistics (&rest rest)
       (ignore rest)
       (save-excursion
         (org-update-parent-todo-statistics)))

     (add-hook 'org-after-refile-insert-hook #'binarin/update-parent-todo-statistics)

     (advice-add 'org-refile :after #'binarin/update-parent-todo-statistics)
     (advice-add 'org-archive-subtree :after #'binarin/update-parent-todo-statistics)
   #+END_SRC

** Babel
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-babel-default-header-args:emacs-lisp '((:lexical . "yes")))

     (setf org-src-window-setup 'current-window)
   #+END_SRC

** Clocking
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-clock-idle-time 15)
     (setq org-clock-auto-clockout-timer 1800)


     (general-setq org-clock-into-drawer "CLOCK")
     (general-setq org-clock-history-length 35)
     (general-setq org-clock-out-remove-zero-time-clocks t)
     (general-setq org-clock-out-when-done t)
     (general-setq org-clock-persist t)
     (general-setq org-clock-persist-query-resume nil)

     (with-eval-after-load 'org-faces
       (set-face-attribute 'org-mode-line-clock nil :background "black")
       (set-face-attribute 'org-mode-line-clock-overrun nil :background "red"))

     (autoload 'org-clock-persistence-insinuate "org-clock")
     (autoload 'org-clock-load "org-clock")
     (autoload 'org-clock-auto-clockout-insinuate "org-clock")
     (with-eval-after-load 'org
       (org-clock-persistence-insinuate)
       (org-clock-load)
       (org-clock-auto-clockout-insinuate))
   #+END_SRC

*** Move to NEXT on clock-in
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun binarin/clock-in-to-next (kw)
        (ignore kw)
        (when (not (and (boundp 'org-capture-mode) org-capture-mode))
          (cond
           ((and (member "REFILE" (org-get-tags)))
            "NEXT")
           ((and (member (org-get-todo-state) (list "TODO"))
                 (binarin/is-task-p))
            "NEXT")
           ((and (member (org-get-todo-state) (list "NEXT"))
                 (binarin/is-project-p))
            "TODO"))))

      (general-setq org-clock-in-switch-to-state 'binarin/clock-in-to-next)
    #+END_SRC

** Projects
*** What is a project
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun binarin/is-todo-heading-p ()
        (member (org-get-todo-state) org-todo-keywords-1))

      (defun binarin/is-task-p ()
        (and (binarin/is-todo-heading-p)
             (not (binarin/is-project-p))))

      (defun binarin/is-project-p ()
        (and (binarin/is-todo-heading-p)
             (member "PROJ" (org-get-tags))))
    #+END_SRC

*** Stuck projects
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-stuck-projects '("+PROJ-agenda_hide/TODO" ("NEXT" "WAIT") nil ""))
    #+END_SRC

*** Adding subtask to a TODO/NEXT task should make it into project
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun binarin/mark-next-parent-tasks-todo ()
        "Visit each parent task and change NEXT states to TODO"
        (when (org-get-todo-state)
          (save-excursion
            (while (org-up-heading-safe)
              (when (member (org-get-todo-state) (list "NEXT" "TODO"))
                (org-todo "TODO")
                (org-set-tags (-union (list "PROJ") (org-get-tags nil t))))))))

      (add-hook 'org-after-todo-state-change-hook 'binarin/mark-next-parent-tasks-todo)
      (add-hook 'org-clock-in-hook 'binarin/mark-next-parent-tasks-todo)
    #+END_SRC

** Links
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-return-follows-link t)
     (setq org-id-link-to-org-use-id 'create-if-interactive)
   #+END_SRC
** Speed commands
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/use-speed-commands-for-other-things ()
       (or (and (bolp) (looking-at org-block-regexp t))
           (looking-at "^#\\+PROPERTY" t)))

     (setq org-use-speed-commands #'binarin/use-speed-commands-for-other-things)

     (defun binarin/org-previous-visible-heading-no-file-header (arg)
       (interactive "p")
       (org-previous-visible-heading arg)
       (when (and (= (point-min) (point))
                  (looking-at "^#\\+PROPERTY" t))
         ;; overshot to #+PROPERTY lines at the beginning of the file
         (org-next-visible-heading 1)))

     (autoload 'org-roam-node-read "org-roam-node")
     (defun binarin/org-roam-refile-strip-id ()
       (interactive)
       (awhen (org-roam-node-read nil nil nil 'require-match)
         (org-delete-property "ID")
         (org-roam-refile it)))

     (with-eval-after-load 'org-agenda
       (keymap-set org-agenda-mode-map (kbd "a") 'org-agenda-archive-default)
       (keymap-set org-agenda-mode-map (kbd "y") 'org-todo-yesterday))

     (with-eval-after-load 'org-keys
       (cl-dolist
           (elt '(("g" . consult-org-heading)
                  ("i" . org-clock-in)
                  ("a" . org-archive-subtree-default)
                  ("k" . binarin/org-previous-visible-heading-no-file-header)
                  ("j" . org-next-visible-heading)
                  ("w" . org-refile)
                  ("m" . binarin/org-roam-refile-strip-id)
                  ("q" . org-set-tags-command)
                  ("r" . (org-refile 3))
                  ("d" . (org-todo "DONE"))))
         (add-to-list 'org-speed-commands elt nil)))
   #+END_SRC
** Roam
   #+begin_src emacs-lisp :tangle yes
     ;; XXX consult-org-roam
     (use-package org-roam
       :after org
       :ensure t
       :custom
       (org-roam-directory (concat (file-name-as-directory org-directory) "roam"))
       (org-roam-completion-everywhere t)
       (org-roam-capture-templates
        '(("d" "default" plain
           "%?"
           :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}")
           :unnarrowed t)))
       (org-roam-dailies-capture-templates
        '(("d" "default" entry "* %<%H:%M>: %?"
           :target (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))
       :functions (org-roam-node-find
                   org-roam-node-insert
                   org-roam-buffer-toggle)
       :config
       (org-roam-db-autosync-mode 1))

     (general-define-key
      "C-c n f" 'org-roam-node-find
      "C-c n i" 'org-roam-node-insert
      "C-c n l" 'org-roam-buffer-toggle)

     (with-eval-after-load "org-roam"
       (cl-defmethod org-roam-node-maybe-file-and-title ((node org-roam-node))
         (if (> (org-roam-node-level node) 0)
             (format "[%s] %s"
                     (org-roam-node-file-title node)
                     (org-roam-node-title node))
           (org-roam-node-title node))))

     (general-setq org-roam-node-display-template
                   (concat "${maybe-file-and-title:*}"
                           (propertize "${tags:10}" 'face 'org-tag)))

     (use-package org-roam-dailies
       :bind-keymap
       (("C-c n d" . org-roam-dailies-map))
       :bind
       (:map org-roam-dailies-map
             ("Y" . org-roam-dailies-capture-yesterday)
             ("T" . org-roam-dailies-capture-tomorrow)))
   #+end_src

** Encryption
   #+begin_src emacs-lisp :tangle yes

     (autoload 'org-encrypt-entries "org-crypt")

     (with-eval-after-load 'org
       (add-hook 'org-mode-hook
                 (lambda () (add-hook 'before-save-hook 'org-encrypt-entries nil t))))

   #+end_src
** Caldav sync
   #+begin_src emacs-lisp :tangle yes
     (use-package org-caldav
       :ensure t
       :after (org)
       :commands (org-caldav-sync)
       :custom
       (org-caldav-url "https://nc.binarin.info/remote.php/dav/calendars/binarin")
       (org-caldav-calendar-id "binarin")
       (org-caldav-inbox "~/org/caldav.org")
       (org-caldav-save-directory org-directory)
       ;; Additional Org files to check for calendar events
       (org-caldav-files org-agenda-files)
       (org-icalendar-timezone "Europe/Amsterdam"))
   #+end_src
** Git sync
   #+begin_src emacs-lisp :tangle yes
     (defun binarin/org-sync ()
       (interactive)
       (when (featurep 'org) ;; org is already loaded
         (org-clock-out nil t)
         (org-save-all-org-buffers)
         (org-store-agenda-views))
       (let ((default-directory "~/org/"))
         (shell-command "./push.sh")))
   #+end_src

** Org global dispatcher
   :PROPERTIES:
   :ORDERED:  t
   :END:
   #+begin_src emacs-lisp :tangle yes
     (autoload 'org-clocking-p "org-clock")

     (defun binarin/org-get-heading-at-marker (marker)
       (save-excursion
         (let (entry)
           (if (and marker (marker-buffer marker)
     	       (buffer-live-p (marker-buffer marker)))
               (progn
                 (set-buffer (marker-buffer marker))
                 (goto-char marker)
                 (setf entry (org-get-heading t t t t))))
           (or entry "<NONE>"))))

     (defun binarin/org-last-capture-headline ()
       (binarin/org-get-heading-at-marker org-capture-last-stored-marker))

     (defvar org-clock-history)
     (defun binarin/org-current-clock-headline ()
       (let* ((clocking (org-clocking-p))
              (marker (if clocking org-clock-marker (car org-clock-history)))
              (prefix (if clocking "Clocked:" "Last clocked:")))
         (if marker
             (format "%s %s" prefix (binarin/org-get-heading-at-marker marker))
           "Clocked: <NONE>")))

     (transient-define-prefix binarin/org-dispatch ()
       "Global dispatcher for org-mode commands."
       [:description "Go to"
                     ("l" org-capture-goto-last-stored
                      :description (lambda ()
                                     (format "Last capture: %s" (binarin/org-last-capture-headline))))
                     ("c" org-clock-goto
                      :description (lambda ()
                                     (binarin/org-current-clock-headline)))]
       [:description "Actions"
                     ("p" "Sync" binarin/org-sync)
                     ("o" "Clock out" org-clock-out)])

     (general-define-key "C-c o" 'binarin/org-dispatch)

   #+end_src
** org-download
   #+begin_src emacs-lisp :tangle yes
     (use-package org-download
       :ensure t
       :commands (org-download-clipboard org-download-enable)
       :config
       (setq org-download-method 'attach))

     (with-eval-after-load 'org
       (add-hook 'org-mode-hook 'org-download-enable))
   #+end_src
** Habits
   #+begin_src emacs-lisp :tangle yes
     (with-eval-after-load "org"
       (load-library "org-habit"))

     (use-package org-habit
       :defer t
       :config
       (setq org-habit-show-all-today t))
   #+end_src
* OS integration
** Type everywhere

From https://thanosapollo.org/posts/use-emacs-everywhere/

   #+begin_src emacs-lisp :tangle yes
     (defun thanos/wtype-text (text)
       "Process TEXT for wtype, handling newlines properly."
       (let* ((has-final-newline (string-match-p "\n$" text))
              (lines (split-string text "\n"))
              (last-idx (1- (length lines))))
         (string-join
          (cl-loop for line in lines
                   for i from 0
                   collect (cond
                            ;; Last line without final newline
                            ((and (= i last-idx) (not has-final-newline))
                             (format "wtype -s 350 %s"
                                     (shell-quote-argument line)))
                            ;; Any other line
                            (t
                             (format "wtype -s 350 %s && wtype -k Return"
                                     (shell-quote-argument line)))))
          " && ")))

     (defun thanos/type ()
       "Launch a temporary frame with a clean buffer for typing."
       (interactive)
       (let ((frame (make-frame '((name . "emacs-float")
                                  (fullscreen . 0)
                                  (undecorated . t)
                                  (width . 70)
                                  (height . 20))))
             (buf (get-buffer-create "emacs-float")))
         (select-frame frame)
         (switch-to-buffer buf)
         (erase-buffer)
         (org-mode)
         (visual-line-mode t)
         (setq-local header-line-format
                     (format " %s to insert text or %s to cancel."
                             (propertize "C-c C-c" 'face 'help-key-binding)
     			(propertize "C-c C-k" 'face 'help-key-binding)))
         (local-set-key (kbd "C-c C-k")
     		   (lambda () (interactive)
     		     (kill-new (buffer-string))
     		     (delete-frame)))
         (local-set-key (kbd "C-c C-c")
     		   (lambda () (interactive)
     		     (start-process-shell-command
     		      "wtype" nil
     		      (thanos/wtype-text (buffer-string)))
     		     (delete-frame)))))
   #+end_src

** Org Capture
   #+begin_src emacs-lisp :tangle yes
     (defun binarin/find-frame-by-name (name)
       (car (filtered-frame-list (lambda (frame) (string-equal name (frame-parameter frame 'name))))))

     (defmacro binarin/with-full-named-frame (name &rest forms)
       (declare (indent 1))
       (let ((name-var (gensym)))
         `(let ((,name-var ,name))
            (let ((display-buffer-overriding-action '((display-buffer-full-frame)))
                  (frame (or (binarin/find-frame-by-name ,name-var)
                             (make-frame (list (cons 'name ,name-var)
                                               (cons 'no-other-frame t)
                                               (cons 'sticky t)
                                               (cons 'undecorated t))))))
              (select-frame-set-input-focus frame t)
              ,@forms))))

     (defun binarin/full-frame-org-capture (&optional keys)
       (binarin/with-full-named-frame "emacs-org-capture"
         (org-capture nil keys)))

     (defun binarin/full-frame-org-roam-dailies-capture-today (&optional keys)
       (binarin/with-full-named-frame "emacs-org-capture"
         (org-roam-dailies-capture-today nil keys)))

     (defun binarin/full-frame-cleanup ()
       (when (string-equal (frame-parameter nil 'name) "emacs-org-capture")
         (delete-frame)))

     (autoload 'org-capture-kill "org-capture")
     (defun binarin/org-capture-kill-on-delete-frame (frame)
       (let ((buffer (window-buffer (frame-first-window frame))))
         (with-current-buffer buffer
           (pcase (buffer-name)
             ((rx "CAPTURE-") (org-capture-kill))))))

     (add-hook 'org-capture-after-finalize-hook 'binarin/full-frame-cleanup)
     (add-hook 'delete-frame-functions 'binarin/org-capture-kill-on-delete-frame)
   #+end_src
* Test space
** [[https://github.com/minad/cape][minad/cape: cape.el - Completion At Point Extensions]]
 :PROPERTIES:
  :ID: 1117a737-2067-4c03-874b-72e8735f3894
  :END:
  [2025-11-18 Tue 17:35]
** ~(setq load-path-filter-function #'load-path-filter-cache-directory-files)~ - after emacs 31 release
** [[https://github.com/abo-abo/org-download][abo-abo/org-download: Drag and drop images to Emacs org-mode]]
 :PROPERTIES:
  :ID: db3ae4d0-2bbf-4e3a-ba21-b0f27e454c5a
  :END:
  [2024-11-24 Sun 09:34]
** [[https://github.com/agzam/mx-piper][agzam/mx-piper: Shell script for piping things in&out of Emacs buffers]]
 :PROPERTIES:
  :ID: 15b0d6ac-1fe3-462d-bd61-d259e26837eb
  :END:
  [2025-10-26 Sun 15:33]
** [[https://github.com/akermu/emacs-libvterm][akermu/emacs-libvterm: Emacs libvterm integration]]
 :PROPERTIES:
  :ID: 59267e8c-3506-46c2-8f87-fb6fc734721c
  :END:
  [2024-11-24 Sun 09:36]
** [[https://github.com/alexluigit/dirvish][alexluigit/dirvish: A polished Dired with batteries included.]]
 :PROPERTIES:
  :ID: ad454f8f-b89a-4b62-be33-36494d769316
  :END:
  [2024-11-24 Sun 09:18]
** [[https://github.com/alphapapa/org-protocol-capture-html][alphapapa/org-protocol-capture-html: Capture HTML from the browser selection into Emacs as org-mode content]]
 :PROPERTIES:
  :ID: 47a0ce00-e3d1-4eb2-a613-31a1c35f1d4c
  :END:
  [2024-11-24 Sun 09:34]
** [[https://lmno.lol/alvaro/an-experimental-e-shell-pager][An experimental (e)shell pager]]
 :PROPERTIES:
  :ID: b81b7885-7138-4be2-b8e8-5d1ebbad9fa3
  :END:
  [2025-01-01 Wed 19:08]
** Android - how to show keyboard
   #+begin_src emacs-lisp
     (defun tk () (interactive) (frame-toggle-on-screen-keyboard (selected-frame) nil))
   #+end_src
** [[https://devdocs.io/ansible/][Ansible documentation  DevDocs]]
 :PROPERTIES:
  :ID: f6f93098-79e1-4a9e-a4d6-32260b225e71
  :END:
  [2024-11-24 Sun 09:15]
** [[https://github.com/bbatsov/crux][bbatsov/crux: A Collection of Ridiculously Useful eXtensions for Emacs]]
 :PROPERTIES:
  :ID: 7836f90a-e4be-44c2-818a-16834b442dd3
  :END:
  [2024-11-24 Sun 09:06]
** [[https://github.com/Chobbes/org-chef][Chobbes/org-chef: A package for making a cookbook and managing recipes with org-mode.]]
 :PROPERTIES:
  :ID: 273e795d-9589-4743-a852-22c4ccbdf8ff
  :END:
  [2025-01-01 Wed 19:15]
** [[https://github.com/copilot-emacs/copilot.el][copilot-emacs/copilot.el: An unofficial Copilot plugin for Emacs.]]
 :PROPERTIES:
  :ID: 55a41bab-8d93-41a9-8407-c16201d0fcf5
  :END:
  [2024-11-24 Sun 09:33]
** [[https://kapeli.com/dash][Dash for macOS - API Documentation Browser, Snippet Manager - Kapeli]]
 :PROPERTIES:
  :ID: 2b1aa146-b08c-45ab-8b35-97eca3844f2f
  :END:
  [2024-11-24 Sun 09:15]
** [[https://github.com/dash-docs-el/helm-dash][dash-docs-el/helm-dash: Browse Dash docsets inside emacs]]
 :PROPERTIES:
  :ID: f1614be4-29ae-465a-a3bc-27ccda375d4e
  :END:
  [2024-11-26 Tue 13:15]

** Devdocs
** [[https://github.com/dgutov/diff-hl][dgutov/diff-hl: Emacs package for highlighting uncommitted changes]]
 :PROPERTIES:
  :ID: a9057aeb-6c78-4581-b39f-a1867ac1eea2
  :END:
  [2024-11-24 Sun 09:36]
** [[https://www.djcbsoftware.nl/code/mu/mu4e.html][djcbsoftware]]
 :PROPERTIES:
  :ID: 7ecc4e7b-b378-4674-9be1-203741a88ec4
  :END:
  [2024-11-24 Sun 09:40]
** [[https://github.com/emacs-eaf/emacs-application-framework?tab=readme-ov-file][emacs-eaf/emacs-application-framework: EAF, an extensible framework that revolutionizes the graphical capabilities of Emacs]]
 :PROPERTIES:
  :ID: 29b8cbc7-088c-43b8-b90f-8175797e76dd
  :END:
  [2024-11-24 Sun 09:38]
** [[https://www.jamescherti.com/emacs-buffer-terminator/][Emacs: buffer-terminator.el  Safely Terminate Emacs Buffers Automatically | James Cherti]]
 :PROPERTIES:
  :ID: 1a279ff8-fce1-46ad-b86d-69b98dbdf851
  :END:
  [2025-01-01 Wed 19:07]
** [[https://protesilaos.com/codelog/2023-06-03-emacs-spacious-padding/][Emacs: my new spacious-padding package | Protesilaos Stavrou]]
 :PROPERTIES:
  :ID: b33cde10-ebc7-4a1e-bcd0-ab26753a7d02
  :END:
  [2025-01-01 Wed 19:14]
** [[https://github.com/emacscollective/no-littering][emacscollective/no-littering: Help keeping ~/.config/emacs clean]]
 :PROPERTIES:
  :ID: e4ef1511-e2cb-4742-be91-08b1d8e1a6ab
  :END:
  [2024-11-24 Sun 09:40]
** [[https://www.emacswiki.org/emacs/DiredPlus][EmacsWiki: Dired Plus]]
 :PROPERTIES:
  :ID: 78cc2e94-a4f1-4e03-9c50-25720e93a767
  :END:
  [2024-11-24 Sun 09:19]
** [[https://www.emacswiki.org/emacs/InferiorEmacsLispMode][EmacsWiki: Inferior Emacs Lisp Mode]]
 :PROPERTIES:
  :ID: 8963a122-2510-461e-b05e-863d0caf42aa
  :END:
  [2024-11-24 Sun 09:32]
** [[https://www.emacswiki.org/emacs/MultiTerm][EmacsWiki: Multi Term]]
 :PROPERTIES:
  :ID: eca420fe-413f-4a6d-bf70-6c53723322fd
  :END:
  [2024-11-24 Sun 09:36]
** [[https://github.com/fniessen/org-html-themes][fniessen/org-html-themes: Transform your Org mode files into stunning HTML documents in minutes with our Org mode HTML theme. Elevate your productivity and impress your readers! #orgmode #html #theme #productivity #design]]
 :PROPERTIES:
  :ID: a9b3ac47-1b7d-4569-a23b-0c3ea3f5a2f4
  :END:
  [2024-11-24 Sun 09:35]
** [[https://github.com/fosskers/transducers.el][fosskers/transducers.el: Ergonomic, efficient data processing for Emacs Lisp.]]
 :PROPERTIES:
  :ID: 15af4b7b-2c6f-4274-b4d0-4864705d8204
  :END:
  [2025-01-01 Wed 18:45]
** [[https://github.com/karthink/gptel][GitHub - karthink/gptel: A simple LLM client for Emacs]]
** [[https://github.com/xenodium/sqlite-mode-extras][GitHub - xenodium/sqlite-mode-extras: Emacs sqlite-mode extras]]
** [[https://github.com/zbelial/treesitter-context.el][GitHub - zbelial/treesitter-context.el: A package built on top of Emacs built-in treesit to show code context, dim surrouding text, and fold code.]]
 :PROPERTIES:
  :ID: ffe770c7-bba0-49ff-b0c7-b39d3f0169b0
  :END:
  [2025-01-06 Mon 10:01]
** [[https://elpa.gnu.org/packages/expreg.html][GNU ELPA - expreg]]
 :PROPERTIES:
  :ID: 631aa604-cae0-40ec-bd96-996666abc7ac
  :END:
  [2024-11-24 Sun 09:12]
** [[https://github.com/ichernyshovvv/org-timeblock][ichernyshovvv/org-timeblock: Schedule your day visually, using timeblocking technique inside Emacs]]
 :PROPERTIES:
  :ID: 92292876-a82d-44ce-b102-24bbac49dd94
  :END:
  [2024-11-24 Sun 09:35]
** [[https://codeberg.org/ideasman42/emacs-fancy-compilation][ideasman42/emacs-fancy-compilation: Emacs compilation-mode enhancements. - Codeberg.org]]
 :PROPERTIES:
  :ID: cc368d71-42cc-45f9-a838-259d97292792
  :END:
  [2024-11-24 Sun 09:16]
** [[https://github.com/joaotavora/breadcrumb][joaotavora/breadcrumb: Emacs headerline indication of where you are in a large project]]
 :PROPERTIES:
  :ID: 651872cc-df10-497c-bef2-803905a961b4
  :END:
  [2025-01-20 Mon 09:30]
** [[https://github.com/kai2nenobu/guide-key][kai2nenobu/guide-key: Guide following keys to an input key sequence automatically and dynamically in Emacs.]]
 :PROPERTIES:
  :ID: e596408d-fa07-4f8b-a737-73520ec0adde
  :END:
  [2024-11-24 Sun 09:34]
** [[https://github.com/karthink/gptel][karthink/gptel: A simple LLM client for Emacs]]
 :PROPERTIES:
  :ID: ed0ba49e-eff9-4478-9e71-098d54132be6
  :END:
  [2024-11-24 Sun 09:34]
** [[https://github.com/leoliu/easy-kill][leoliu/easy-kill: Kill & Mark Things Easily in Emacs]]
 :PROPERTIES:
  :ID: 55d130f9-519e-4283-b986-bef6f6fa94ee
  :END:
  [2025-01-01 Wed 19:14]
** [[https://github.com/magit/forge][magit/forge: Work with Git forges from the comfort of Magit]]
 :PROPERTIES:
  :ID: 27dc746f-fb0a-48a8-8e06-4d57305b71f0
  :END:
  [2024-11-24 Sun 09:36]
** [[https://github.com/manateelazycat/color-rg][manateelazycat/color-rg: Search and refactoring tool based on ripgrep.]]
 :PROPERTIES:
  :ID: 3359adb3-a6e1-4de7-ad95-665cf3a46c57
  :END:
  [2024-11-24 Sun 09:39]
** [[https://github.com/mickeynp/combobulate][mickeynp/combobulate: Structured Editing and Navigation in Emacs with Tree-Sitter]]
 :PROPERTIES:
  :ID: e115334f-d952-40ae-a8d9-18d223ff8ca2
  :END:
  [2025-01-01 Wed 18:35]
** [[https://github.com/narendraj9/hledger-mode][narendraj9/hledger-mode: An Emacs major mode for Hledger]]
 :PROPERTIES:
  :ID: 414938d9-9e9c-46d4-a215-a2ab9578b656
  :END:
  [2024-11-24 Sun 09:40]

** [[https://etown.dev/nice-org-html/README][Nice Org to HTML pipeline]]
 :PROPERTIES:
  :ID: 9f4497a2-213a-4099-a668-81d84a6a74ae
  :END:
  [2025-01-01 Wed 19:08]

** [[https://www.reddit.com/r/emacs/comments/1h5t31o/omdash_03_improved_github_support_imap_support/?share_id=hUy9ZiftaMN3UVABZOlVY][om-dash 0.3: improved github support, imap support, more : r/emacs]]
 :PROPERTIES:
  :ID: 00cdeb5f-3981-4f77-9844-303579a6d487
  :END:
  [2025-01-01 Wed 18:58]
** [[https://ox-hugo.scripter.co/][ox-hugo - Org to Hugo exporter]]
 :PROPERTIES:
  :ID: 415f017c-a45d-4967-80a2-e5e5090f94b0
  :END:
  [2024-11-24 Sun 09:39]
** [[https://shaunlebron.github.io/parinfer/][Parinfer - simpler Lisp editing]]
 :PROPERTIES:
  :ID: 5fa409fd-6165-458d-88dc-0e6fbb408da9
  :END:
  [2025-01-21 Tue 06:36]
** [[https://github.com/positron-solutions/dslide][positron-solutions/dslide: Present anything Emacs can do with programmable, extensible, configurable slides made from org mode headings]]
 :PROPERTIES:
  :ID: a908e7c6-97d9-4dc2-86e8-5c13d11f034f
  :END:
  [2024-11-24 Sun 09:35]
** [[https://github.com/positron-solutions/moc][positron-solutions/moc: Master of Ceremonies. Display & presentation utilities to make presentation packages more effective]]
 :PROPERTIES:
  :ID: 04a3574b-4f25-42e5-ba23-1b8fb623908e
  :END:
  [2025-01-01 Wed 19:15]
** [[https://github.com/radian-software/el-patch][radian-software/el-patch:  Future-proof your Emacs Lisp customizations!]]
 :PROPERTIES:
  :ID: 9e814763-b384-4e41-9d6d-9d18d7ac82bc
  :END:
  [2024-11-24 Sun 09:40]
** [[https://github.com/ragnard/tabby-mode?tab=readme-ov-file][ragnard/tabby-mode: An Emacs mode for the Tabby AI coding assistant]]
 :PROPERTIES:
  :ID: be0ddaf9-0d38-4adb-baa8-39ca0e0c48b8
  :END:
  [2024-11-24 Sun 09:33]
** [[https://github.com/ReanGD/emacs-multi-compile][ReanGD/emacs-multi-compile: emacs package multi-compile]]
 :PROPERTIES:
  :ID: e6353313-0eff-4073-924f-f50fbae155c8
  :END:
  [2024-11-24 Sun 09:17]
** [[https://github.com/rksm/org-ai][rksm/org-ai: Emacs as your personal AI assistant. Use LLMs such as ChatGPT or LLaMA for text generation or DALL-E and Stable Diffusion for image generation. Also supports speech input / output.]]
 :PROPERTIES:
  :ID: d8f6a7d1-28fb-4b62-a8ed-46a01a12f308
  :END:
  [2024-11-24 Sun 09:33]
** [[https://github.com/sshaw/git-link][sshaw/git-link: Emacs package to get the GitHub/Bitbucket/GitLab/... URL for a buffer location]]
 :PROPERTIES:
  :ID: 6a38328f-9bb8-4df7-9824-889bacc2a8be
  :END:
  [2024-11-24 Sun 09:36]
** [[https://github.com/suntsov/efar][suntsov/efar: A FAR-like file manager for Emacs]]
 :PROPERTIES:
  :ID: b5008a88-4bc3-42be-854e-8518b2134c0e
  :END:
  [2024-11-24 Sun 09:21]
** [[https://github.com/svaante/dape][svaante/dape: Debug Adapter Protocol for Emacs]]
 :PROPERTIES:
  :ID: 99d7c1e2-6845-4a47-bb2b-221011c2711b
  :END:
  [2025-01-01 Wed 19:10]
** [[https://github.com/tumashu/posframe][tumashu/posframe: Pop a posframe (just a child-frame) at point, posframe is a **GNU ELPA** package!]]
 :PROPERTIES:
  :ID: cb11770f-819c-4573-b201-fa964d542569
  :END:
  [2025-01-01 Wed 19:13]
** [[https://github.com/vedang/pdf-tools][vedang/pdf-tools: Emacs support library for PDF files.]]
 :PROPERTIES:
  :ID: a01220f2-cd78-4cfd-a332-2ecb09d72bae
  :END:
  [2024-11-24 Sun 09:39]
** [[https://github.com/weirdNox/org-noter][weirdNox/org-noter: Emacs document annotator, using Org-mode]]
 :PROPERTIES:
  :ID: a08aebe0-c216-4efb-9ab8-35651707f8e7
  :END:
  [2024-11-24 Sun 09:35]
** [[https://github.com/zwild/eshell-prompt-extras][zwild/eshell-prompt-extras: Display extra information and color for your eshell prompt.]]
 :PROPERTIES:
  :ID: 21d0b3ed-990d-4ca6-b644-90f6517cd5d1
  :END:
  [2024-11-24 Sun 09:37]

* Footer

  Make sure that our hook is absolutely at the end.
  #+begin_src emacs-lisp :tangle yes
     (add-hook 'window-setup-hook 'binarin/report-full-startup-time 100)
  #+end_src

# Local Variables:
# compile-command: "tangle-emacs-org-babel-config emacs-config.org /tmp/"
# eval: (add-hook 'after-save-hook 'recompile 98 t)
# End:
