#+PROPERTY: header-args:emacs-lisp :lexical yes
* File header
** Warnings
~defvar~ to suppress compilation warnings about free variable assignment
#+begin_src emacs-lisp :tangle yes
  (defvar native-comp-async-report-warnings-errors 'silent)
#+end_src
** Track execution time

Whatever happens before this point, we don't control
(i.e. ~site-lisp.el~).  So I want to report full time but also the
time it takes to execute this file with all hooks in 'after-init-hooks
executed.
#+begin_src emacs-lisp :tangle yes
  (defconst binarin/before-personal-init-file-time (current-time))
  (defun binarin/report-full-startup-time ()
    (message "Emacs initialized in %f seconds"
             (float-time (time-subtract (current-time)
                                        binarin/before-personal-init-file-time))))
  (add-hook 'emacs-startup-hook 'binarin/report-full-startup-time 100)
#+end_src

** ~use-package~

   ~use-package~ documentation says to wrap it into
   ~eval-when-compile~, but it's not enough.

   #+begin_src emacs-lisp :tangle yes
     (require 'use-package)
   #+end_src

** Startup debug
    #+begin_src emacs-lisp :tangle no
      (eval-and-compile
        (setq use-package-verbose 'debug)
        (setq use-package-minimum-reported-time 0.0))

      (defun sh/current-time-microseconds ()
        "Return the current time formatted to include microseconds."
        (let* ((nowtime (current-time))
               (now-ms (nth 2 nowtime)))
          (concat (format-time-string "[%Y-%m-%dT%T" nowtime) (format ".%d]" now-ms))))

      (defun sh/ad-timestamp-message (FORMAT-STRING &rest args)
        "Advice to run before `message` that prepends a timestamp to each message.

      Activate this advice with:
      (advice-add message :before `sh/ad-timestamp-message)"
        (ignore args)                         ;
        (unless (string-equal FORMAT-STRING "%s%s")
          (let ((deactivate-mark nil)
                (inhibit-read-only t))
            (with-current-buffer "*Messages*"
              (goto-char (point-max))
              (if (not (bolp))
                (newline))
              (insert (sh/current-time-microseconds) " ")))))

      (advice-add 'message :before 'sh/ad-timestamp-message)
    #+end_src
** Customization helpers
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package dash :ensure t)
     (use-package f :ensure t)
     (use-package general :ensure t)
     (use-package anaphora :ensure t)
     (use-package s :ensure t)
     (require 's)
     (require 'f)
     (require 'cl-macs)
     (require 'dash)
     (require 'anaphora)
   #+END_SRC
** What system we are running on?
#+begin_src emacs-lisp :tangle yes
  (defconst binarin/system-type
    (cond
     ((getenv "WSL_DISTRO_NAME") 'wsl)
     ((s-equals? system-type "darwin") 'darwin)
     (t 'linux)))
#+end_src
* Appearance
** Theme
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package zenburn-theme
       :ensure t)
     (load-theme 'zenburn t)
     (set-face-attribute 'lazy-highlight nil :background "red")
   #+END_SRC

** Frame size
   Don't create too big of a frame on WSL (and it doesn't matter for tiling WMs).
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'default-frame-alist '(height . 24))
     (add-to-list 'default-frame-alist '(width . 80))
   #+END_SRC

** No toolbars/scrollbars
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (window-system)
       (toggle-scroll-bar -1)
       (tool-bar-mode -1))
     (menu-bar-mode -1)

     (setf (alist-get 'vertical-scroll-bars default-frame-alist) nil)
   #+END_SRC

** Tab bar
   Only show tab bar when there is more than one tab
   #+begin_src emacs-lisp :tangle yes
     (general-setq tab-bar-show 1)
   #+end_src

** Font
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'default-frame-alist
                  `(font . ,(cl-case binarin/system-type
                              (wsl "Iosevka-18")
                              (darwin "JetBrains Mono-14")
                              (t "Iosevka-22"))))

     (setf face-ignored-fonts '("Adobe Blank"))
   #+END_SRC
** Modeline
#+begin_src emacs-lisp :tangle yes
  (use-package telephone-line
    :ensure t
    :commands (telephone-line-mode))
  (telephone-line-mode 1)
#+end_src

** Long lines handling
   Truncate long lines by default:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default truncate-lines t)
   #+END_SRC

   Use fringe when ~visual-line-mode~ is in effect:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
   #+END_SRC

* Behaviour
* Disable startup screen
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq inhibit-startup-screen t)
   #+END_SRC

** Disable ~suspend-frame~
#+begin_src emacs-lisp :tangle yes
   (put 'suspend-frame 'disabled t)
#+end_src

** Evil
   #+begin_src emacs-lisp :tangle yes
     (use-package evil
       :ensure t
       :bind
       (("C-z" . evil-mode)))
     (general-setq evil-default-state 'emacs)
   #+end_src
** Change "yes or no" to "y or n"
   #+begin_src emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src
** Start maximized by default
#+begin_src emacs-lisp :tangle yes
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Windows-specific
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (eq binarin/system-type 'wsl)
       (setq browse-url-browser-function 'browse-url-generic
     	      browse-url-generic-program "wslview"))
   #+END_SRC
** Prevent accidental exit
   Prompt on C-x C-c - no more accidential exits
   #+begin_src emacs-lisp :tangle yes
     (setq confirm-kill-emacs #'y-or-n-p
           confirm-kill-processes nil)
   #+end_src
** Keeping a lot of history
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'savehist)
     (require 'recentf)
     (setq history-length 1000
           history-delete-duplicates t
           savehist-file "~/.emacs.d/savehist"
           savehist-additional-variables '(savehist-minibuffer-history-variables
                                           read-expression-history
                                           minibuffer-history
                                           file-name-history
                                           mark-ring
                                           search-ring
                                           extended-command-history
                                           kill-ring
                                           search-ring
                                           regexp-search-ring
                                           compile-history
                                           command-history)
           recentf-max-saved-items 1000)
     (savehist-mode 1)
     (recentf-mode 1)
   #+END_SRC
** Writeable grep buffers
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package wgrep
       :ensure t
       :hook
       (grep-setup-hook . wgrep-setup))
   #+END_SRC
** Completion everywhere
   #+begin_src emacs-lisp :tangle yes
     (use-package vertico
       :ensure t)
     (vertico-mode)
     (general-define-key :keymaps 'minibuffer-mode-map
                    "C-l" 'vertico-directory-delete-word)

     ;; showing additional docs during completion
     (use-package marginalia
       :ensure t)
     (marginalia-mode)

     ;; search by first letters of words in any order
     (use-package orderless
       :ensure t)
     (setq completion-styles '(orderless basic)
           completion-category-overrides '((file (styles basic partial-completion))))

     (use-package consult
       :ensure t
       :commands (consult-history)
       :autoload (consult-register--candidates consult--get-location consult--jump-state consult-xref)
       :bind
       (("C-c M-x"   . consult-mode-command)
        ("C-h C-i"   . consult-info)                ;; The same as "C-h TAB"
        ("M-y"       . consult-yank-pop)
        ("C-x r s"   . consult-register-store)
        ("C-x r SPC" . consult-register-store)
        ("C-x r j"   . consult-register-load)

        ;; C-x bindings in `ctl-x-map'
        ("C-x M-:"   . consult-complex-command)     ;; orig. repeat-complex-command
        ("C-x b"     . consult-buffer)              ;; orig. switch-to-buffer
        ("C-x 4 b"   . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
        ("C-x 5 b"   . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
        ("C-x t b"   . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
        ("C-x r b"   . consult-bookmark)            ;; orig. bookmark-jump
        ("C-x p b"   . consult-project-buffer)      ;; orig. project-switch-to-buffer

        ;; M-g bindings in `goto-map'
        ("M-g e"     . consult-compile-error)
        ("M-g f"     . consult-flymake)             ;; Alternative: consult-flycheck
        ("M-g g"     . consult-goto-line)           ;; orig. goto-line
        ("M-g M-g"   . consult-goto-line)           ;; orig. goto-line
        ("M-g o"     . consult-outline)             ;; Alternative: consult-org-heading
        ("M-g m"     . consult-mark)
        ("M-g k"     . consult-global-mark)
        ("M-g i"     . consult-imenu)
        ("M-g I"     . consult-imenu-multi)

        ;; M-s bindings in `search-map'
        ("M-s d"     . consult-find)                ;; Alternative: consult-fd
        ("M-s c"     . consult-locate)
        ("M-s g"     . consult-grep)
        ("M-s G"     . consult-git-grep)
        ("M-s r"     . consult-ripgrep)
        ("M-s l"     . consult-line)
        ("M-s L"     . consult-line-multi)
        ("M-s k"     . consult-keep-lines)
        ("M-s u"     . consult-focus-lines)

        ;; Isearch integration
        ("M-s e"     . consult-isearch-history)
        :map isearch-mode-map
        ("M-e"       . consult-isearch-history)     ;; orig. isearch-edit-string
        ("M-s e"     . consult-isearch-history)     ;; orig. isearch-edit-string
        ("M-s l"     . consult-line)                ;; needed by consult-line to detect isearch
        ("M-s L"     . consult-line-multi)          ;; needed by consult-line to detect isearch

        ;; Minibuffer history
        :map minibuffer-local-map
        ("M-s"       . consult-history)             ;; orig. next-matching-history-element
        ("M-r"       . consult-history))                 ;; orig. previous-matching-history-element

       :config
       (setq register-preview-delay 0.5
             register-preview-function 'consult-register-format)
       (add-to-list 'consult-buffer-sources 'consult-source-point-register 'append)
       (setq consult-project-function (lambda (_) (projectile-project-root))))

     (eval-after-load "xref"
       (general-setq xref-show-xrefs-function 'consult-xref
                     xref-show-definitions-function 'consult-xref))

     (eval-after-load "em-hist"
       (general-define-key
        :keymaps 'eshell-hist-mode-map
        "M-r" 'consult-history))

     (defun consult--point-register-p (reg)
       "Return non-nil if REG is a point register."
       (markerp (cdr reg)))

     (defvar consult-source-point-register
       `(:name     "Point Register"
         :narrow   (?r . "Register")
         :category consult-location
         :state
         ,(lambda ()
            (let ((state (consult--jump-state)))
              (lambda (action cand)
                (funcall state action (and cand (car (consult--get-location cand)))))))
         :enabled
         ,(lambda () (seq-some #'consult--point-register-p register-alist))
         :items
         ,(lambda () (consult-register--candidates #'consult--point-register-p)))
       "Point register source.")

     (use-package embark
       :ensure t
       :bind
       ((("C-;" . embark-act)
         :map embark-file-map
         ("S" . sudo-edit))))

     (use-package embark-consult
       :ensure t
       :hook
       (embark-collect-mode . consult-preview-at-point-mode))

     ;; completion in pop-up window
     (use-package corfu
       :ensure t
       :init
       (global-corfu-mode)
       ;; Remap with Power Toys for msrdc program
       (when (eq binarin/system-type 'wsl)
         (general-define-key :keymaps 'corfu-map
                             "C-M-S-SPC" 'corfu-insert-separator)))
   #+end_src

** External shell
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq shell-file-name "/bin/sh") ;; mostly for TRAMP, should work everywhere
   #+END_SRC

** Dired
   #+BEGIN_SRC emacs-lisp
     (add-hook 'dired-mode-hook 'dired-hide-details-mode)
     (setq dired-dwim-target t)
   #+END_SRC

** Magit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package magit
       :ensure t
       :commands (magit-git-insert)
       :bind
       (("C-x g" . magit-status)))
   #+END_SRC

** Saving and backups
   Save backups to one place and don't clutter filesystem with files ending in ~\~~ or ~#~.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar binarin/backups-directory "~/.emacs.d/backups")
     (make-directory binarin/backups-directory t)
     (setq backup-directory-alist `(("." . ,binarin/backups-directory)))

     (defvar binarin/auto-save-directory "~/.emacs.d/auto-save-list/")
     (make-directory binarin/auto-save-directory t)
     (setq auto-save-file-name-transforms `((".*" ,binarin/auto-save-directory t)))
   #+END_SRC

   Never delete backup files and never re-use them (this generates
   ~200 megs per year with my usage patterns), they can help to
   recover from a lot of fuckups like ~git reset --hard~:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq version-control t)
     (setq delete-old-versions -1)
   #+END_SRC

   The fact that file is under version control is no reason to exclude
   it from this backup scheme (hello again, ~git reset --hard~):
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq vc-make-backup-files t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (global-auto-revert-mode +1)
   #+END_SRC

   #+begin_src emacs-lisp :tangle yes
     (defun binarin/setup-gpg-maybe ()
       (when (and buffer-file-name (string-match epa-file-name-regexp buffer-file-name))
         (message "Backup inhibited for this file")
         (setq-local backup-inhibited t)
         (auto-save-mode -1)
         (when (fboundp 'undo-tree-mode)
           (with-suppressed-warnings ((unresolved undo-tree-mode))
               (undo-tree-mode -1)))))

     (add-hook 'find-file-hook 'binarin/setup-gpg-maybe)
   #+end_src
** Mark
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mark-ring-max 64
           set-mark-command-repeat-pop t
           global-mark-ring-max 64)
   #+END_SRC
** Whitespace handling
   #+BEGIN_SRC emacs-lisp :tangle yes
     (general-define-key "M-SPC" 'cycle-spacing)
     (setq-default indent-tabs-mode nil)

     (defun binarin/show-trailing-whitespace ()
       (setq show-trailing-whitespace t))
     (add-hook 'prog-mode-hook #'binarin/show-trailing-whitespace)

     (use-package ws-butler
       :ensure t
       :config
       (ws-butler-global-mode +1))

     (setq require-final-newline 'ask-me)
     (setq tab-always-indent 'complete)
   #+END_SRC
** Killing
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq kill-do-not-save-duplicates t
           kill-ring-max 256)
   #+END_SRC
** Clipboard
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq save-interprogram-paste-before-kill t)
   #+END_SRC
** Bookmarks
   Save bookmarks every time bookmark is modified
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq bookmark-save-flag 1)
   #+END_SRC
** Narrowing
   #+BEGIN_SRC emacs-lisp :tangle yes
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC
** Line numbers
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq line-number-display-limit-width 1000)
   #+END_SRC

** Search
   #+BEGIN_SRC emacs-lisp
     (setq isearch-allow-scroll t
           search-ring-max 128
           regexp-search-ring-max 128)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/search-words ()
       (interactive)
       (when (use-region-p)
	 (browse-url
	  (concat "https://duckduckgo.com/html/?q="
		  (url-hexify-string (buffer-substring (region-beginning) (region-end)))))))

     (general-define-key "M-s M-w" 'binarin/search-words)
   #+END_SRC

** Automatically make scripts executable
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'after-save-hook
	       'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC
** Window handling
   Prefer horizontal splits:
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq split-width-threshold 100)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (winner-mode)
   #+END_SRC
** I18n
*** Prefer Russian and UTF-8
#+begin_src emacs-lisp :tangle yes
  (set-language-environment "Russian")
  (setq default-input-method "russian-computer")
  (prefer-coding-system 'utf-8-unix)
#+end_src

** Server
  #+begin_src emacs-lisp :tangle yes
    (require 'server)

    ;; don't try starting server if it's already running in another instance
    (defun binarin/server-start ()
          (unless (server-running-p server-name)
            (server-start)))

    (add-hook 'after-init-hook #'binarin/server-start)
  #+end_src

** TRAMP
   #+begin_src emacs-lisp :tangle yes
     (eval-after-load "tramp"
       (general-setq tramp-login-prompt-regexp ".*\\(user\\|login\\|2FA Token\\)\\( .*\\)?: *"))

     (setq vc-ignore-dir-regexp
           (format "\\(%s\\)\\|\\(%s\\)"
                   vc-ignore-dir-regexp
                   tramp-file-name-regexp))
   #+end_src
** Direnv
   #+begin_src emacs-lisp :tangle yes
     (use-package direnv
       :ensure t
       :config
       (direnv-mode)
       (advice-add 'direnv--summarise-changes :around 'binarin/cleanup_direnv--summarise-changes)
       :custom
       ((direnv-always-show-summary t)
        (direnv-show-paths-in-summary nil)))

     (defvar binarin/direnv-boring-items
       '("AR" "AS" "CC" "CONFIG_SHELL" "CXX" "DEVENV_DOTFILE" "DEVENV_STATE" "HOST_PATH" "IN_NIX_SHELL" "LD"
         "NIX_BINTOOLS" "NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu"
         "NIX_BUILD_CORES" "NIX_CC" "NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu"
         "NIX_CFLAGS_COMPILE" "NIX_ENFORCE_NO_NATIVE" "NIX_HARDENING_ENABLE" "NIX_INDENT_MAKE"
         "NIX_LDFLAGS" "NIX_STORE" "NM" "OBJCOPY" "OBJDUMP" "RANLIB" "READELF" "SIZE"
         "SOURCE_DATE_EPOCH" "STRINGS" "STRIP" "XML_CATALOG_FILES"
         "buildInputs" "buildPhase" "builder" "cmakeFlags" "configureFlags" "depsBuildBuild"
         "depsBuildBuildPropagated" "depsBuildTarget" "depsBuildTargetPropagated"
         "depsHostHost" "depsHostHostPropagated" "depsTargetTarget" "depsTargetTargetPropagated"
         "doCheck" "doInstallCheck" "dontAddDisableDepTrack" "mesonFlags" "name" "nativeBuildInputs"
         "out" "outputs" "patches" "phases" "propagatedBuildInputs" "propagatedNativeBuildInputs"
         "shell" "shellHook" "stdenv" "strictDeps" "system" "XDG_DATA_DIRS" "__structuredAttrs" "preferLocalBuild"))

     (defun binarin/cleanup_direnv--summarise-changes (orig-fun items)
       (funcall orig-fun (-remove (lambda (elt) (-elem-index (car elt) binarin/direnv-boring-items)) items)))

   #+end_src
* Programming
** Projects
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package projectile
       :ensure t
       :commands (projectile-make-relative-to-root projectile-project-root)
       :bind-keymap
       ("C-c p" . projectile-command-map)
       :config
       (setq projectile-keymap-prefix (kbd "C-c p"))
       (setq projectile-enable-caching t)
       (setq projectile-completion-system 'default)
       ;; For my projects I usually don't want to include submodules in file
       ;; list. And anyway, this is broken for some of the things I work on
       ;; (e.g. it fails on submodules without url).
       (setq projectile-git-submodule-command nil)
       (projectile-mode +1))

     (use-package projectile-ripgrep
       :ensure t
       :commands (projectile-ripgrep))
   #+END_SRC

** Perl
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defalias 'perl-mode 'cperl-mode)
     (general-setq cperl-hairy t
     	      cperl-indent-level 4
     	      cperl-indent-parens-as-block t
     	      cperl-close-paren-offset -4)
     (add-hook 'cperl-mode-hook 'ws-butler-mode)
   #+END_SRC

** Lisp
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package paredit
       :ensure t
       :hook
       (emacs-lisp-mode                  . paredit-mode)
       (lisp-mode                        . paredit-mode)
       (lisp-interaction-mode            . paredit-mode)
       (eval-expression-minibuffer-setup . paredit-mode)
       :bind
       (:map paredit-mode-map
             ("RET" . paredit-newline)
             ("C-j" . nil)))
   #+END_SRC

   Doesn't play good with paredit.
   #+begin_src emacs-lisp :tangle yes
     (electric-indent-mode -1)
   #+end_src

** Nix
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package nix-mode
       :ensure t
       :mode "\\.nix\\'")
   #+END_SRC

** Share source position
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/get-git-remote-urls ()
       (with-temp-buffer
         (magit-git-insert "remote" "-v")
         (-remove #'null (-map #'(lambda (a) (nth 1 (s-split "[ \t]+" a))) (s-lines (buffer-string))))))

     (defun binarin/get-head-commit-sha ()
       (with-temp-buffer
         (magit-git-insert "rev-parse" "HEAD")
         (s-trim (buffer-string))))

     (defun binarin/make-gitlab-link (base project)
       (let ((commit-sha (binarin/get-head-commit-sha))
             (filename-relative (car (projectile-make-relative-to-root (list (buffer-file-name)))))
             (line-number (string-to-number (format-mode-line "%l"))))
         (format "https://%s/%s/blob/%s/%s#L%d" base project commit-sha filename-relative line-number)))

     (defun binarin/make-github-link (project)
       (let ((commit-sha (binarin/get-head-commit-sha))
             (filename-relative (car (projectile-make-relative-to-root (list (buffer-file-name)))))
             (line-number (string-to-number (format-mode-line "%l"))))
         (format "https://%s/%s/blob/%s/%s#L%d" "github.com" project commit-sha filename-relative line-number)))

     (defun binarin/open-web-link-to-source-code ()
       (interactive)
       (require 'magit)
       (aif (cl-block loop
              (dolist (url (binarin/get-git-remote-urls))
                (acond
                   ((s-match  "\\(gitlab\\.[^/:]+\\)[:/]\\(.*?\\)\\(\\.git\\)?$" url)
                    (cl-return (binarin/make-gitlab-link (nth 1 it) (nth 2 it))))
                   ((or
                     (s-match "https://github.com/\\(.*\\)" url)
                     (s-match "git@github.com:\\(.*\\)" url))
                    (cl-return (binarin/make-github-link (nth 1 it)))))))
           (browse-url it)
         (message "Failed to generate a link from that file")))
   #+END_SRC
* Org mode
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; XXX Use consult for clock-in
    (use-package org
      :ensure t
      :mode ("\\.org\\'" . org-mode)
      :bind
      (("C-c a" . org-agenda)
       ("C-c r" . org-capture))
      :config
      (setq org-agenda-files (-map #'f-expand
                                   (-filter #'f-exists?
                                            '("~/org/personal.org"
                                              "~/org/contacts.org"
                                              "~/org/caldav.org"
                                              "~/org/refile.org"
                                              "~/org/ference.org")))
            org-directory "~/org"))

    (use-package org-super-agenda
      :ensure t
      :config
      (setq org-super-agenda-header-separator ""
            org-super-agenda-header-prefix "")
      (org-super-agenda-mode 1)
      :after (org))

    (use-package org-contrib
      :ensure t
      :defer)
  #+END_SRC
** Todo keywords
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-todo-keywords
           '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
             (type "|" "CANCELLED(c!)")
             (type "WAIT(w!)" "|")))

     (setq org-todo-keyword-faces
           '(("TODO" :foreground "red" :weight bold)
             ("NEXT" :foreground "cyan3" :weight bold)
             ("DONE" :foreground "green4" :weight bold)

             ("WAIT" :foreground "orange3" :weight bold)
             ("CANCELLED" :foreground "forest green" :weight bold)))

     (setq org-enforce-todo-dependencies t)
     (setq org-log-done 'time)

     (setq org-log-into-drawer t)
   #+END_SRC

** Tags
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-fast-tag-selection-single-key 't)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-tags-exclude-from-inheritance '("PROJ"))
     (setq org-tag-alist `((:startgroup . nil)
                            ("@home" . ?h)
                            ("@errand" . ?e)
                            (:endgroup . nil)
                            (:startgroup . nil)
                            ("PROJ" . ?p)
                            (:endgroup . nil)))
   #+END_SRC

** Outline
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-cycle-separator-lines 0)
     (setq org-fold-catch-invisible-edits 'smart)
     (setq org-startup-folded t)
     (setq org-adapt-indentation t)
     (general-setq org-goto-interface 'outline-path-completion)
   #+END_SRC

** Agenda
   #+begin_src emacs-lisp :tangle yes
     (general-setq org-agenda-include-diary nil)
     (general-setq org-agenda-span 'day)
     (general-setq org-agenda-start-on-weekday 1)
     (general-setq org-agenda-window-setup 'other-tab)
     (general-setq org-agenda-dim-blocked-tasks nil)
     (general-setq org-agenda-compact-blocks t)
     (general-setq org-agenda-block-separator nil)
     (general-setq org-agenda-skip-scheduled-if-done t)
     (general-setq org-agenda-skip-deadline-if-done t)
     (general-setq org-agenda-skip-timestamp-if-done t)
     (setq org-agenda-hide-tags-regexp "agenda_hide")
     (setq
      ;; Agenda styling
      org-agenda-block-separator ?─
      org-agenda-time-grid
      '((daily today require-timed)
        (800 1000 1200 1400 1600 1800 2000)
        " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
      org-agenda-current-time-string
      "◀── now ─────────────────────────────────────────────────")
   #+end_src

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun binarin/shrink-text ()
       (when (and
              (window-system)
              (or (not (boundp 'text-scale-mode))
                  (with-suppressed-warnings ((free-vars text-scale-mode))
                    (not text-scale-mode))))
         (text-scale-increase 0)
         (text-scale-increase -1)))

     (eval-after-load "org-agenda"
       (when (window-system)
         (add-hook 'org-agenda-mode-hook #'binarin/shrink-text)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-agenda-tags-column 0
           org-tags-column 0
           org-auto-align-tags nil
           org-special-ctrl-a/e t
           org-insert-heading-respect-content t
           org-hide-emphasis-markers t
           org-pretty-entities t)
   #+END_SRC
** Templates
   #+BEGIN_SRC emacs-lisp :tangle yes
     (eval-after-load "org-mode"
       (lambda ()
         (require 'org-tempo)
         (add-to-list 'org-structure-template-alist '("m" . "src emacs-lisp"))))
   #+END_SRC
** Priorities
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-highest-priority ?A
            org-lowest-priority ?D
            org-default-priority ?C)

   #+END_SRC
** Contacts
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-contacts
       :ensure t
       :after (org)
       :config
       (setq org-contacts-files '("~/org/contacts.org")))
   #+END_SRC

** Appearance
   #+BEGIN_SRC emacs-lisp :tangle yes
          (use-package org-modern
            :ensure t
            :after (org)
            :config
            (global-org-modern-mode))

          ;; Ellipsis styling
          (setq org-ellipsis "…")
          (with-eval-after-load 'org
            (set-face-attribute 'org-ellipsis nil :inherit 'default :box nil))

   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/org-agenda-mode-hook ()
       ;; Always highlight the current agenda line
       (hl-line-mode 1))

     (add-hook 'org-agenda-mode-hook
               'binarin/org-agenda-mode-hook
               'append)
   #+END_SRC
** Capture
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-capture-templates
                     '(("t" "todo" entry
                        (file "~/org/refile.org")
                        "* TODO %?\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %u\n  %a"
                        :clock-in t :clock-resume t)
                       ("n" "comment on clocked" plain
                        (clock)
                        "%?")
                       ("l" "Link" entry
                        (file "~/org/refile.org")
                        "* TODO %a\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %U\n\n  %i" :immediate-finish t)))

     (setq org-default-notes-file "~/org/refile.org")

     (defun binarin/hide-drawers-hook ()
       (save-excursion
         (goto-char (point-min))
         (org-cycle-hide-drawers 'children)))

     (add-hook 'org-capture-mode-hook #'binarin/hide-drawers-hook)
     (add-hook 'org-capture-mode-hook #'auto-fill-mode)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (autoload 'org-protocol-detect-protocol-server "org-protocol")

     (defun org-protocol-lazy-load (args)
       (if (or (featurep 'org-protocol)
               (not (delq nil
                          (mapcar (lambda (loc)
                                    ;; loc: (file-name . (line . column))
                                    (string-match-p "\\(?:^\\|[/\\\\]\\)org-protocol:" (car loc)))
                                  (car args)))))
           args
         (org-protocol-detect-protocol-server args)))

     (advice-add 'server-visit-files :filter-args #'org-protocol-lazy-load)

     (autoload 'notifications-notify "notifications")

     (defun binarin/display-notify-after-capture (&rest args)
       (ignore args)
       (notifications-notify
        :title "Link captured"
        :body (cadar org-stored-links)
        :app-name "emacs"
        :app-icon (expand-file-name "~/.local/share/images/org.svg")
        :timeout 3000
        :urgency 'low))

     (advice-add 'org-protocol-capture :after #'binarin/display-notify-after-capture)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar binarin/org-protocol-mundane-link-descriptions
       '(" - YouTube"))

     (defun binarin/org-protocol-capture-postprocess ()
       (save-excursion
         (goto-char (point-min)))
       (awhen (s-match "binarin@binarin.ru - Mail\\]\\]" (buffer-string))
         (save-excursion
           (goto-char (point-min))
           (while (re-search-forward "https://mail\\.google\\.com/mail/u/[0-9]/" (point-max) t)
             (replace-match "https://mail.google.com/mail/u/?authuser=binarin@binarin.ru"))))
       (awhen (re-search-forward (concat (regexp-opt binarin/org-protocol-mundane-link-descriptions t) "]]") nil t) ;
         (replace-match "]]")))

     (add-hook 'org-capture-prepare-finalize-hook #'binarin/org-protocol-capture-postprocess)
   #+END_SRC
** Refile
   #+BEGIN_SRC emacs-lisp :tangle yes
     ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
     (setq org-refile-targets '((org-agenda-files :maxlevel . 9)
                                (nil :maxlevel . 9)))

     ; Use full outline paths for refile targets - we file directly with IDO
     (setq org-refile-use-outline-path 'file)

     ; Targets complete directly with IDO
     (setq org-outline-path-complete-in-steps nil)

     ; Allow refile to create parent tasks with confirmation
     (setq org-refile-allow-creating-parent-nodes 'confirm)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun binarin/update-parent-todo-statistics (&rest rest)
       (ignore rest)
       (save-excursion
         (org-update-parent-todo-statistics)))

     (add-hook 'org-after-refile-insert-hook #'binarin/update-parent-todo-statistics)

     (advice-add 'org-refile :after #'binarin/update-parent-todo-statistics)
     (advice-add 'org-archive-subtree :after #'binarin/update-parent-todo-statistics)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; XXX use consult for refiling and add those as high-prio targets
     (defconst binarin/common-tasks-for-refiling
       '(("personal-next" . "ece10822-11d9-4939-b3e2-2d660c0a29ad")
         ("personal-projects" . "f43d2ba5-e840-4382-85da-ff2bf10ff9de")
         ("personal-scheduled" . "13d7a494-3f80-4ffe-a7b4-bded42335342")))

   #+END_SRC

** Babel
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-babel-default-header-args:emacs-lisp '((:lexical . "yes")))
   #+END_SRC

** Clocking
   #+BEGIN_SRC emacs-lisp :tangle yes
     (general-setq org-clock-into-drawer "CLOCK")
     (general-setq org-clock-history-length 35)
     (general-setq org-clock-out-remove-zero-time-clocks t)
     (general-setq org-clock-out-when-done t)
     (general-setq org-clock-persist t)
     (general-setq org-clock-persist-query-resume nil)

     (with-eval-after-load 'org-faces
       (set-face-attribute 'org-mode-line-clock nil :background "black")
       (set-face-attribute 'org-mode-line-clock-overrun nil :background "red"))

     (autoload 'org-clock-persistence-insinuate "org-clock")
     (autoload 'org-clock-load "org-clock")
     (with-eval-after-load 'org
       (org-clock-persistence-insinuate)
       (org-clock-load))
   #+END_SRC

*** Move to NEXT on clock-in
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun binarin/clock-in-to-next (kw)
        (ignore kw)
        (when (not (and (boundp 'org-capture-mode) org-capture-mode))
          (cond
           ((and (member (org-get-todo-state) (list "TODO"))
                 (binarin/is-task-p))
            "NEXT")
           ((and (member (org-get-todo-state) (list "NEXT"))
                 (binarin/is-project-p))
            "TODO"))))

      (general-setq org-clock-in-switch-to-state 'binarin/clock-in-to-next)
    #+END_SRC

** Projects
*** What is a project
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun binarin/is-todo-heading-p ()
        (member (org-get-todo-state) org-todo-keywords-1))

      (defun binarin/is-task-p ()
        (and (binarin/is-todo-heading-p)
             (not (binarin/is-project-p))))

      (defun binarin/is-project-p ()
        (and (binarin/is-todo-heading-p)
             (member "PROJ" (org-get-tags))))
    #+END_SRC

*** Stuck projects
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-stuck-projects '("+PROJ-agenda_hide/!TODO" ("NEXT" "WAIT") nil ""))
    #+END_SRC

*** Adding subtask to a TODO/NEXT task should make it into project
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun binarin/mark-next-parent-tasks-todo ()
        "Visit each parent task and change NEXT states to TODO"
        (when (org-get-todo-state)
          (save-excursion
            (while (org-up-heading-safe)
              (when (member (org-get-todo-state) (list "NEXT" "TODO"))
                (org-todo "TODO")
                (org-set-tags (-union (list "PROJ") (org-get-tags nil t))))))))

      (add-hook 'org-after-todo-state-change-hook 'binarin/mark-next-parent-tasks-todo)
      (add-hook 'org-clock-in-hook 'binarin/mark-next-parent-tasks-todo)
    #+END_SRC

** Links
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-return-follows-link t)
     (setq org-id-link-to-org-use-id 'create-if-interactive)
   #+END_SRC
** Speed commands
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-use-speed-commands t)

     (with-eval-after-load 'org-keys
       (cl-dolist
           (elt '(("g" . consult-org-heading)
                  ("i" . org-clock-in)
                  ("j" . org-previous-visible-heading)
                  ("k" . org-next-visible-heading)
                  ("r" . org-refile)))
         (add-to-list 'org-speed-commands elt nil)))
   #+END_SRC
** Roam
   #+begin_src emacs-lisp :tangle yes
     ;; XXX consult-org-roam
     (use-package org-roam
       :after org
       :ensure t
       :custom
       (org-roam-directory (concat (file-name-as-directory org-directory) "roam"))
       (org-roam-completion-everywhere t)
       (org-roam-capture-templates
        '(("d" "default" plain
           "%?"
           :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}")
           :unnarrowed t)))
       (org-roam-dailies-capture-templates
        '(("d" "default" entry "* %<%H:%M>: %?"
           :target (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))
       :bind (("C-c n f" . org-roam-node-find)
              ("C-c n i" . org-roam-node-insert)
              ("C-c n l" . org-roam-buffer-toggle))
       :config
       (org-roam-db-autosync-mode 1))

     (use-package org-roam-dailies
       :bind-keymap
       (("C-c n d" . org-roam-dailies-map))
       :bind
       (:map org-roam-dailies-map
             ("Y" . org-roam-dailies-capture-yesterday)
             ("T" . org-roam-dailies-capture-tomorrow)))
#+end_src

** Encryption
#+begin_src emacs-lisp :tangle yes

  (autoload 'org-encrypt-entries "org-crypt")

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook
              (lambda () (add-hook 'before-save-hook 'org-encrypt-entries nil t))))

#+end_src
** Sync
   #+begin_src emacs-lisp :tangle yes
     (use-package org-caldav
       :ensure t
       :after (org)
       :commands (org-caldav-sync)
       :custom
       (org-caldav-url "https://nc.binarin.info/remote.php/dav/calendars/binarin")
       (org-caldav-calendar-id "binarin")
       (org-caldav-inbox "~/org/caldav.org")
       (org-caldav-save-directory org-directory)
       ;; Additional Org files to check for calendar events
       (org-caldav-files (-difference org-agenda-files org-contacts-files))
       (org-icalendar-timezone "Europe/Amsterdam"))
       #+end_src
* Test space
